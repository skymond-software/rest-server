////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                   Copyright (c) 2012-2024 Skymond, LLC.                    //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included    //
// in all copies or substantial portions of the Software.                     //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//                               Skymond, LLC                                 //
//                            https://skymond.io                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// Doxygen marker
/// @file

#include "SqlClientLib.h"
#include "CThreads.h"
#include "Scope.h"
#include "Vector.h"

#ifdef LOGGING_ENABLED
#include "LoggingLib.h"
#else
#undef printLog
#define printLog(...) {}
#define logFile stderr
#define LOG_MALLOC_FAILURE(...) {}
#endif

bool sqlInvalidateTableDescription(void *db,
  const char *dbName, const char *tableName);

/// @fn extern inline bool sqlEnsureFieldTypes(SqlDatabase *sqlDatabase, const char *dbName, const char *tableName, DbResult *dbResult)
///
/// @brief Make sure the field types of a DbResult are correct before returning
/// it to the caller.
///
/// @details
/// This exists because SQLite has some funky way of recording types.  Even
/// though the types of the columns in the schema don't change, the types as
/// recorded in the tables will change depending on how the data was written.
/// This can show up, for instance, if you write to a field with a string type
/// using blob syntax.  The SQLite connector uses the types of the first row as
/// the types for the fields in the returned DbResult, which can give
/// inconsistent results relative to the schema.  So, we have to do this before
/// returning a result to make sure SQLite didn't goof something up under the
/// covers.
///
/// @note
/// You *CAN NOT* use sqlGetFieldTypeByIndex here because you don't know what
/// fields were requested by the caller.  The only thing that's 100% reliable
/// are the field names.
///
/// @param sqlDatabase A pointer to the SqlDatabase that holds the metadata for
///   the connection.
/// @param dbName The name of the database that was used in the query.
/// @param tableName The name of the table that was used in the query.
/// @param dbResult A pointer to the DbResult that was generated by the query.
///
/// @return Returns true on success, false on failure.
extern inline bool sqlEnsureFieldTypes(SqlDatabase *sqlDatabase, const char *dbName,
  const char *tableName, DbResult *dbResult
) {
  bool returnValue = true;
  TypeDescriptor *type = NULL;
  
  if ((sqlDatabase == NULL) || (dbName == NULL)
    || (tableName == NULL) || (dbResult == NULL)
  ) {
    // Don't bother.
    printLog(ERR, "One or more NULL parameters.\n");
    printLog(ERR, "sqlDatabase=%p, dbName=%s, tableName=%s, dbResult=%p\n",
      sqlDatabase, strOrNull(dbName), strOrNull(tableName), dbResult);
    return false;
  }
  
  if (sqlDatabase->sqlDbType == SQLITE) {
    const char **fieldNames = dbGetFieldNames(dbResult);
    if (fieldNames == NULL) {
      // Not even anything we can do here.
      printLog(ERR, "NULL field names.\n");
      return false;
    }
    for (u64 ii = 0; ii < dbResult->numFields; ii++) {
      if (fieldNames[ii] == NULL) {
        // Somehow, we have a value of numFields that's greater than the actual
        // number of elements in the fieldNames array.  Not sure how that's
        // possible, but bail.
        printLog(ERR, "fieldNames[%llu] is NULL.  dbResult->numFields = %llu\n",
          llu(ii), llu(dbResult->numFields));
        returnValue = false;
        break;
      }
      
      type = sqlGetFieldTypeByName(sqlDatabase,
        dbName, tableName, fieldNames[ii]);
      if (type != NULL) {
        dbResult->fieldTypes[ii] = type;
      } else {
        printLog(ERR, "sqlGetFieldTypeByName(%p, %s, %s, %s) returned NULL.\n",
          sqlDatabase, strOrNull(dbName), strOrNull(tableName),
          strOrNull(fieldNames[ii]));
        returnValue = false;
      }
    }
  }
  
  return returnValue;
}

/// @fn const char *typeDescriptorToSqlTypeName(TypeDescriptor *type)
///
/// @brief Convert a type descriptor to its equivalent SQL type.
///
/// @param type A pointer to a TypeDescriptor to convert.
///
/// @return Returns a string representing the SQL type on success,
/// NULL on failure
const char *typeDescriptorToSqlTypeName(TypeDescriptor *type) {
  printLog(TRACE,
    "ENTER typeDescriptorToSqlTypeName(typeDescriptor=%p)\n",
    type);
  
  const char *typeName = NULL;
  int typeDescriptorIndex = getIndexFromTypeDescriptor(type);
  if (typeDescriptorIndex < 0) {
    // Not a type.
    printLog(TRACE,
      "EXIT typeDescriptorToSqlTypeName(typeDescriptor=%p) = {NULL}\n",
      type);
    return typeName;
  } else if (typeDescriptorIndex <= getIndexFromTypeDescriptor(typeU128)) {
    typeName = "BIGINT";
  } else if (typeDescriptorIndex <= getIndexFromTypeDescriptor(typeLongDouble)) {
    typeName = "DOUBLE";
  } else if (typeDescriptorIndex <= getIndexFromTypeDescriptor(typeStringCiNoCopy)) {
    typeName = "LONGTEXT";
  } else if (typeDescriptorIndex <= getIndexFromTypeDescriptor(typeBytesNoCopy)) {
    typeName = "LONGBLOB";
  }
  
  printLog(TRACE, "EXIT typeDescriptorToSqlTypeName(typeDescriptor=%s) = {%s}\n",
    type->name, (typeName != NULL) ? typeName : "NULL");
  return typeName;
}

/// @fn TypeDescriptor* sqlTypeNameToTypeDescriptor(const char *typeInfo)
///
/// @brief Look up the TypeDescriptor for a SQL column type name.
///
/// @param typeInfo A string describing the type of the column.
///
/// @return Returns a pointer to the appropriate TypeDescriptor on success,
/// NULL on failure (NULL input).
TypeDescriptor* sqlTypeNameToTypeDescriptor(const char *typeInfo) {
  printLog(TRACE, "ENTER sqlTypeNameToTypeDescriptor(typeInfo=\"%s\")\n",
    typeInfo);
  
  if (typeInfo == NULL) {
    printLog(ERR, "NULL typeInfo provided.  Cannot get type.\n");
    printLog(TRACE,
      "EXIT sqlTypeNameToTypeDescriptor(typeInfo=\"%s\") = {NULL}\n",
      typeInfo);
    return NULL;
  }
  
  TypeDescriptor *type = typeI64; // default
  // Using SQLite rules.  Order is important.
  if (!strstrci(typeInfo, "int")) {
    if (strstrci(typeInfo, "char")
      || strstrci(typeInfo, "clob")
      || strstrci(typeInfo, "text")
    ) {
      type = typeString;
    } else if (strstrci(typeInfo, "blob")) {
      type = typeBytes;
    } else if (strstrci(typeInfo, "real")
      || strstrci(typeInfo, "floa")
      || strstrci(typeInfo, "doub")
    ) {
      type = typeDouble;
    }
  }
  
  printLog(TRACE, "EXIT sqlTypeNameToTypeDescriptor(typeInfo=\"%s\") = {%s}\n",
    typeInfo, type->name);
  return type;
}

/// @fn DbResult* _sqlFixMissingFields(DbResult *dbResult, const char *dbName, const char *tableName, const char *select)
///
/// @brief Fix missing fields from an empty DbResult.
///
/// @param dbResult The DbResult to fix.
/// @param sqlDatabase A pointer to the SqlDatabase to connect to.
/// @param dbName The name of the database in the SqlDatabase.
/// @param tableName The name of the table the results are from.
/// @param select The string containing the fields that were selected.  May be
///   the wildcard "*".
///
/// @return Returns a new DbResult with the proper field information.
DbResult* _sqlFixMissingFields(DbResult *dbResult, SqlDatabase *sqlDatabase,
  const char *dbName, const char *tableName, const char *select
) {
  printLog(TRACE,
    "ENTER _sqlFixMissingFields(dbResult, sqlDatabase=%p, dbName=\"%s\", "
    "tableName=\"%s\", select=\"%s\") = {successful}\n",
    sqlDatabase, dbName, tableName, select);
  
  // Re-initialize the DbResult.
  dbResult = dbFreeResult(dbResult);
  dbResult = (DbResult*) calloc(1, sizeof(DbResult));
  if (dbResult == NULL) {
    LOG_MALLOC_FAILURE();
    exit(1);
  }
  // The only way this function is ever called is when dbResult->successful is
  // true and dbResult->numFields is 0, so we know how to initialize
  // dbResult->successful.
  dbResult->successful = true;
  
  DbResult *tableDescription = sqlDescribeTable(sqlDatabase, dbName, tableName);
  
  dbResult->numFields = tableDescription->numResults;
  dbResult->fieldTypes = (TypeDescriptor**) calloc(1,
    dbResult->numFields * sizeof(TypeDescriptor*));
  dbResult->rows = (void***) calloc(1, 2 * sizeof(void**));
  dbResult->rows[0] = (void**) calloc(1, (dbResult->numFields + 1) * sizeof(void*));
  dbResult->rows[1] = NULL;
  dbResult->numRows = 1;
  
  Bytes *fieldNames = stringToBytesArray(select, ",");
  if ((fieldNames == NULL)
    || ((fieldNames[0] != NULL) && (fieldNames[1] == NULL)
      && (*fieldNames[0] == '*'))
  ) {
    // Select all fields.  The usual case.
    for (u64 field = 0; field < tableDescription->numResults; field++) {
      Bytes fieldName = dbGetBytesByName(tableDescription, field, "fieldName");
      bytesAddBytes((Bytes*) &dbResult->rows[0][field], fieldName);
      TypeDescriptor *type = sqlTypeNameToTypeDescriptor(dbGetStringByName(
        tableDescription, field, "typeInfo"));
      dbResult->fieldTypes[field] = type;
    }
  } else {
    // Add the fields in order.
    u64 numFields = 0;
    for (; fieldNames[numFields] != NULL; numFields++) {
      Bytes fieldName = fieldNames[numFields];
      for (u64 field = 0; field < tableDescription->numResults; field++) {
        // The field name could have spaces or tabs in it, so we need to use it
        // as the haystack and the value in tableDescription as the needle.
        if (strstr(str(fieldName),
          dbGetStringByName(tableDescription, field, "fieldName"))
        ) {
          bytesAddBytes((Bytes*) &dbResult->rows[0][numFields],
            dbGetBytesByName(tableDescription, field, "fieldName"));
          TypeDescriptor *type = sqlTypeNameToTypeDescriptor(dbGetStringByName(
            tableDescription, field, "typeInfo"));
          dbResult->fieldTypes[numFields] = type;
          break;
        }
      }
      if (dbResult->rows[0][numFields] == NULL) {
        printLog(ERR, "Could not find field \"%s\" in table \"%s\".\n",
          str(fieldName), tableName);
      }
    }
    
    dbResult->numFields = numFields;
    // We're not going to shrink dbResult->fieldTypes or dbResult->rows.
    // No point.
  }
  
  fieldNames = freeBytesArray(fieldNames);
  tableDescription = dbFreeResult(tableDescription);
  
  printLog(TRACE,
    "EXIT _sqlFixMissingFields(dbResult, sqlDatabase=%p, dbName=\"%s\", "
    "tableName=\"%s\", select=\"%s\") = {successful}\n",
    sqlDatabase, dbName, tableName, select);
  return dbResult;
}

/// @fn i32 sqlBuildTableDescriptions(SqlDatabase *sqlDatabase, const char *dbName, const char *tableName)
///
/// @brief Build the table descriptions for the SqlDatabase.
///
/// @param sqlDatabase A pointer to a SqlDatabase to query.
/// @param dbName The name of the database in the system to query.
/// @param tableName The name of the table to describe.
///
/// @return Returns 0 on success, -1 on failure.
i32 sqlBuildTableDescriptions(SqlDatabase *sqlDatabase,
  const char *dbName, const char *tableName
) {
  printLog(TRACE,
    "ENTER sqlBuildTableDescriptions(sqlDatabase=%p, dbName=\"%s\", "
    "tableName=\"%s\")\n", sqlDatabase, dbName, tableName);
  
  DbResult *queryResult = sqlDescribeTable(sqlDatabase, dbName, tableName);
  if ((queryResult == NULL) || (queryResult->successful == false)) {
    printLog(ERR, "Table %s.%s does not exist.\n", dbName, tableName);
    queryResult = dbFreeResult(queryResult);
    printLog(TRACE,
      "EXIT sqlBuildTableDescriptions(sqlDatabase=%p, dbName=\"%s\", "
      "tableName=\"%s\") = {-1}\n", sqlDatabase, dbName, tableName);
    return -1;
  }
  
  HashTable *tableDescriptionHt = htCreate(typeString);
  for (u64 row = 0; row < queryResult->numResults; row++) {
    const char *fieldName = dbGetStringByName(queryResult, row, "fieldName");
    TypeDescriptor *type = sqlTypeNameToTypeDescriptor(dbGetStringByName(
      queryResult, row, "typeInfo"));
    htAddEntry(tableDescriptionHt, fieldName, type, typePointerNoCopy);
  }
  
  Bytes lookupKey = NULL;
  bytesAddStr(&lookupKey, dbName);
  bytesAddStr(&lookupKey, tableName);
  bytesAddStr(&lookupKey, "HashTable");
  
  HashNode *node = htAddEntry(sqlDatabase->tableDescriptions,
    lookupKey, tableDescriptionHt, typeHashTableNoCopy);
  if (node != NULL) {
    // Make the destructor active.
    node->type = typeHashTable;
  }
  lookupKey = bytesDestroy(lookupKey);
  
  Vector *tableDescriptionVector = vectorCreate(typePointerNoCopy);
  for (u64 row = 0; row < queryResult->numResults; row++) {
    TypeDescriptor *type = sqlTypeNameToTypeDescriptor(dbGetStringByName(
      queryResult, row, "typeInfo"));
    vectorSetEntry(tableDescriptionVector, row, type, typePointerNoCopy);
  }
  
  bytesAddStr(&lookupKey, dbName);
  bytesAddStr(&lookupKey, tableName);
  bytesAddStr(&lookupKey, "Vector");
  
  node = htAddEntry(sqlDatabase->tableDescriptions,
    lookupKey, tableDescriptionVector, typeVectorNoCopy);
  if (node != NULL) {
    // Make the destructor active.
    node->type = typeVector;
  }
  lookupKey = bytesDestroy(lookupKey);
  
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlBuildTableDescriptions(sqlDatabase=%p, dbName=\"%s\", "
    "tableName=\"%s\") = {0}\n", sqlDatabase, dbName, tableName);
  return 0;
}

/// @fn u64 sqlGetNumFields(void *db, const char *dbName, const char *tableName)
///
/// @brief Get the number of fields in a table.
///
/// @param db A pointer to a SqlDatabase object cast to a void*.
/// @param dbName The name of the database managed by the db pointer where the
///   table resides.  Note that this is the name *WITHOUT* the dbInstance.
/// @param tableName The name of the talbe to query.
///
/// @return Returns the number of fields in the specified table.  Note that if
/// the table doesn't exist, this value will be 0.
u64 sqlGetNumFields(void *db, const char *dbName, const char *tableName) {
  SqlDatabase *sqlDatabase = (SqlDatabase*) db;
  
  SCOPE_ENTER("db=%p, dbName=%s, tableName=%s",
    db, strOrNull(dbName), strOrNull(tableName));
  
  Bytes lookupKey = NULL;
  bytesAddStr(&lookupKey, dbName);
  bytesAddStr(&lookupKey, tableName);
  bytesAddStr(&lookupKey, "Vector");
  mtx_lock(sqlDatabase->tableDescriptions->lock);
  Vector *tableDescription
    = (Vector*) htGetValue(sqlDatabase->tableDescriptions, lookupKey);
  if (tableDescription == NULL) {
    sqlBuildTableDescriptions(sqlDatabase, dbName, tableName);
    tableDescription
      = (Vector*) htGetValue(sqlDatabase->tableDescriptions, lookupKey);
  }
  mtx_unlock(sqlDatabase->tableDescriptions->lock);
  lookupKey = bytesDestroy(lookupKey);
  
  u64 returnValue = 0;
  if (tableDescription != NULL) {
    returnValue = tableDescription->size;
  }
  
  SCOPE_EXIT("db=%p, dbName=%s, tableName=%s", "%llu",
    db, strOrNull(dbName), strOrNull(tableName), llu(returnValue));
  return returnValue;
}

/// @fn DbResult* sqlGetValues_(SqlDatabase *database, const char *dbName, const char *tableName, const char *select, const char *orderBy, ...)
///
/// @brief Get one or more values from the database.
///
/// @details This is a wrapper function that calls getValuesVargs.  This
///   function is itself wrapped by a #define that appends a NULL as the last
///   argument to make the code cleaner and be more intuitive to future code
///   authors.
///
/// @param database A pointer to the SqlDatabase object representing the
///   database system to query.
/// @param dbName The name of the database to query.
/// @param tableName The name of the table to query.
/// @param select The name of the field to interrotgae.
/// @param orderBy The field(s) to order by, if any.  This parameter may be
///   NULL.
/// @param ... All further parameters are C string pairs.  The first of the
///   two strings is the name of the field to investigate and the next string
///   is the value desired for that field in the query.  The qurey is
///   terminated by a NULL pointer which is automatically provided by the
///   sqlGetValues macro that wraps this function.
///
/// @return A DbResult object with the results of the query.
DbResult* sqlGetValues_(SqlDatabase *database,
  const char *dbName, const char *tableName,
  const char *select, const char *orderBy, ...
) {
  printLog(TRACE,
    "ENTER sqlGetValues_(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "select=\"%s\", orderBy=\"%s\")\n",
    database, dbName, tableName, select, (orderBy != NULL) ? orderBy : "");
  
  va_list args;
  va_start(args, orderBy);
  DbResult *returnValue = sqlGetValuesVargs(database, dbName,
    tableName, select, orderBy, args);
  va_end(args);
  // We don't have access to the original database, so we're providing NULL
  // here.  This will mean we won't be able to successfully call dbUpdateResult
  // (or anything else that depends on this pointer), but that's probably OK.
  dbFinalizeResult(returnValue, NULL, dbName, tableName);
  
  printLog(TRACE,
    "EXIT sqlGetValues_(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "select=\"%s\", orderBy=\"%s\") = {%llu results}\n",
    database, dbName, tableName, select, (orderBy != NULL) ? orderBy : "",
    llu(returnValue->numResults));
  return returnValue;
}

/// @fn DbResult* sqlGetValuesVargs(SqlDatabase *database, const char *dbString, const char *tableName, const char *select, const char *orderBy, va_list args)
///
/// @brief Low-level method for retrieving values from a table in a database.
///
/// @details This is a support function intented to only be called from other
///   parts of this library.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database to qurey.
/// @param tableName The name of the table to query.
/// @param select The name of the field to examine.
/// @param orderBy The field(s) to order by, if any.  This parameter may be
///   NULL.
/// @param args The representation of the query.
///
/// @return A DbResult with the results of the query.
DbResult* sqlGetValuesVargs(SqlDatabase *database,
  const char *dbString, const char *tableName,
  const char *select, const char *orderBy, va_list args
) {
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE,
    "ENTER sqlGetValuesVargs(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "select=\"%s\", orderBy=\"%s\")\n",
    database, dbName, tableName, select, (orderBy != NULL) ? orderBy : "");
  
  Bytes query = NULL;
  DbResult *queryResult = NULL;
  DbResult *returnValue = (DbResult*) calloc(1, sizeof(DbResult));
  if (returnValue == NULL) {
    LOG_MALLOC_FAILURE();
    exit(1);
  }
  
  // Get the field types.
  Bytes lookupKey = NULL;
  bytesAddStr(&lookupKey, dbString);
  bytesAddStr(&lookupKey, tableName);
  bytesAddStr(&lookupKey, "HashTable");
  HashTable *tableDescription
    = (HashTable*) htGetValue(database->tableDescriptions, lookupKey);
  if (tableDescription == NULL) {
    sqlBuildTableDescriptions(database, dbString, tableName);
    tableDescription
      = (HashTable*) htGetValue(database->tableDescriptions, lookupKey);
  }
  lookupKey = bytesDestroy(lookupKey);
  
  bytesAddStr(&query, "select ");
  bytesAddStr(&query, select);
  bytesAddStr(&query, " from ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  char *fieldArg = va_arg(args, char*);
  if (fieldArg != NULL) {
    printLog(DEBUG, "Adding \"%s\"\n", fieldArg);
    bytesAddStr(&query, " where ");
  }
  while (fieldArg != NULL) {
    if (!dbIsFieldNameValid(fieldArg)) {
      printLog(ERR, "Invalid characters in argument \"%s\".\n", fieldArg);
      query = bytesDestroy(query);
      dbName = stringDestroy(dbName);
      queryResult = dbFreeResult(queryResult);
      printLog(TRACE, "EXIT sqlGetValuesVargs() = {0 results)\n");
      return returnValue; // Empty result
    }
    
    TypeDescriptor *type
      = (TypeDescriptor*) htGetValue(tableDescription, fieldArg);
    if (type == NULL) {
      printLog(ERR, "Field name \"%s\" is not part of table %s.%s.\n",
        fieldArg, dbString, tableName);
      query = bytesDestroy(query);
      dbName = stringDestroy(dbName);
      queryResult = dbFreeResult(queryResult);
      printLog(TRACE, "EXIT sqlGetValuesVargs() = {0 results)\n");
      return returnValue; // Empty result
    }
    
    bytesAddStr(&query, fieldArg);
    bytesAddStr(&query, "=");
    if ((type == typeBytes) || (type == typeString)) {
      if (fieldArg != NULL) {
        char *stringArg = va_arg(args, char*);
        printLog(DEBUG, "Adding \"%s\"\n", stringArg);
        Bytes escapedArg = NULL;
        if (type == typeString) {
          escapedArg = database->makeStringLiteral(stringArg);
        } else { // type == typeBytes
          Bytes bytesArg = NULL;
          bytesAddStr(&bytesArg, stringArg);
          escapedArg = database->makeBytesLiteral(bytesArg);
          bytesArg = bytesDestroy(bytesArg);
        }
        printLog(DEBUG, "Escaped string\n");
        bytesAddBytes(&query, escapedArg);
        escapedArg = bytesDestroy(escapedArg);
      } else if (type == typeString) {
        bytesAddStr(&query, "''");
      } else { // type == typeBytes
        bytesAddStr(&query, "NULL");
      }
    } else { // Invalid type.
      void *arg = va_arg(args, void*);
      char *stringValue = type->toString(arg);
      bytesAddStr(&query, stringValue);
      stringValue = stringDestroy(stringValue);
    }
    
    fieldArg = va_arg(args, char*);
    if (fieldArg != NULL) {
      bytesAddStr(&query, " and ");
    }
  }
  
  if ((orderBy != NULL) && (*orderBy != '\0')) {
    bytesAddStr(&query, " order by ");
    bytesAddStr(&query, orderBy);
  }
  bytesAddStr(&query, ";");
  printLog(DEBUG, "Running query \"%s\"\n", query);
  queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  printLog(DEBUG, "Got %llu query results \n", llu(queryResult->numResults));
  
  returnValue = dbFreeResult(returnValue);
  returnValue = queryResult;
  
  if (returnValue->numFields > 0) {
    sqlEnsureFieldTypes(database, dbString, tableName, returnValue);
  } else if ((returnValue->successful == true)
    && (returnValue->numFields == 0)
  ) {
    // This isn't a valid state.  We issued a select statement that was
    // successful but returned no fields.  That means the whole result is empty.
    // Fix this.
    returnValue
      = _sqlFixMissingFields(returnValue, database, dbString, tableName, select);
  }
  
  printLog(TRACE,
    "EXIT sqlGetValuesVargs(dbName=\"%s\", tableName=\"%s\", select=\"%s\", "
    "orderBy=\"%s\") = {%llu results}\n",
    dbName, tableName, select, (orderBy != NULL) ? orderBy : "",
    llu(returnValue->numResults));
  dbName = stringDestroy(dbName);
  return returnValue;
}

/// @fn DbResult* sqlGetValuesDict(SqlDatabase *database, const char *dbString, const char *tableName, const char *select, const char *orderBy, Dictionary *args)
///
/// @brief Low-level method for retrieving values from a table in a database.
///
/// @details This is a support function intented to only be called from other
///   parts of this library.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database to qurey.
/// @param tableName The name of the table to query.
/// @param select The name of the field to examine.
/// @param orderBy The field(s) to order by, if any.  This parameter may be
///   NULL.
/// @param args The representation of the query.
///
/// @return A DbResult with the results of the query.
DbResult* sqlGetValuesDict(SqlDatabase *database,
  const char *dbString, const char *tableName,
  const char *select, const char *orderBy, Dictionary *args
) {
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE,
    "ENTER sqlGetValuesDict(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "select=\"%s\", orderBy=\"%s\")\n",
    database, dbName, tableName, (orderBy != NULL) ? orderBy : "", select);
  
  Bytes query = NULL;
  
  bytesAddStr(&query, "select ");
  bytesAddStr(&query, select);
  bytesAddStr(&query, " from ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  
  if ((args != NULL) && (args->head != NULL)) {
    int keyTypeIndex = getIndexFromTypeDescriptor(args->keyType);
    int typeStringIndex = getIndexFromTypeDescriptor(typeString);
    int typeBytesNoCopyIndex = getIndexFromTypeDescriptor(typeBytesNoCopy);
    if ((keyTypeIndex >= typeStringIndex)
      && (keyTypeIndex <= typeBytesNoCopyIndex)
    ) {
      int typeStringNoCopyIndex = getIndexFromTypeDescriptor(typeStringNoCopy);
      int typeBytesIndex = getIndexFromTypeDescriptor(typeBytes);
      Bytes escapedValue = NULL;
      bytesAddStr(&query, " where ");
      
      for (DictionaryEntry *node = args->head; node != NULL; node = node->next) {
        bytesAddStr(&query, (char*) node->key);
        bytesAddStr(&query, "=");
        
        int valueTypeIndex = getIndexFromTypeDescriptor(node->type);
        if ((valueTypeIndex >= typeStringIndex)
          && (valueTypeIndex <= typeStringNoCopyIndex)
        ) {
          escapedValue = database->makeStringLiteral((char*) node->value);
        } else if ((valueTypeIndex >= typeBytesIndex)
          && (valueTypeIndex <= typeBytesNoCopyIndex)
        ) {
          escapedValue = database->makeBytesLiteral((Bytes) node->value);
        } else {
          escapedValue = node->type->toBytes(node->value);
        }
        
        bytesAddBytes(&query, escapedValue);
        escapedValue = bytesDestroy(escapedValue);
        
        if (node->next != NULL) {
          bytesAddStr(&query, " and ");
        }
      }
    }
  }
  
  if (orderBy != NULL) {
    bytesAddStr(&query, " order by ");
    bytesAddStr(&query, orderBy);
  }
  bytesAddStr(&query, ";");
  
  printLog(DEBUG, "Running query \"%s\"\n", query);
  DbResult *returnValue
    = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  printLog(DEBUG, "Got %llu query results \n", llu(returnValue->numResults));
  
  if (returnValue->numFields > 0) {
    sqlEnsureFieldTypes(database, dbString, tableName, returnValue);
  } else if ((returnValue->successful == true)
    && (returnValue->numFields == 0)
  ) {
    // This isn't a valid state.  We issued a select statement that was
    // successful but returned no fields.  That means the whole result is empty.
    // Fix this.
    returnValue
      = _sqlFixMissingFields(returnValue, database, dbString, tableName, select);
  }
  
  printLog(TRACE,
    "EXIT sqlGetValuesDict(dbName=\"%s\", tableName=\"%s\", select=\"%s\", "
    "orderBy=\"%s\") = {%llu results}\n",
    dbName, tableName, select, (orderBy != NULL) ? orderBy : "",
    llu(returnValue->numResults));
  dbName = stringDestroy(dbName);
  return returnValue;
}

/// @fn bool sqlAddRecordVargs(SqlDatabase *database, const char *dbString, const char *tableName, va_list args)
///
/// @brief Add a new record to a table in a database.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database the table is in.
/// @param tableName The name of the table to add a record to.
/// @param args A va_list of C strings.  The values are position dependent and
///   must match the full field definitions of the specified table.  The
///   parameters are terminated by a NULL pointer.
///
/// @return True on success, false on failure.
bool sqlAddRecordVargs(SqlDatabase *database,
  const char *dbString, const char *tableName, va_list args
) {
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE,
    "ENTER sqlAddRecordVargs(database=%p, dbName=\"%s\", tableName=\"%s\")\n",
    database, dbName, tableName);
  
  bool returnValue = false;
  Bytes query = NULL;
  DbResult *queryResult = NULL;
  
  int typeLongDoubleIndex = getIndexFromTypeDescriptor(typeLongDouble);
  int typeStringCiNoCopyIndex = getIndexFromTypeDescriptor(typeStringCiNoCopy);
  int typeBytesNoCopyIndex = getIndexFromTypeDescriptor(typeBytesNoCopy);
  
  bytesAddStr(&query, "insert into ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  bytesAddStr(&query, " values(");
  void *fieldValue = va_arg(args, void*);
  u64 numFields = sqlGetNumFields(database, dbString, tableName);
  for (u64 fieldIndex = 0; fieldIndex < numFields; fieldIndex++) {
    TypeDescriptor *fieldType
      = sqlGetFieldTypeByIndex(database, dbString, tableName, fieldIndex);
    printLog(DEBUG, "Field (%s, %s, %llu) is of type \"%s\".\n",
      dbString, tableName, llu(fieldIndex),
      (fieldType != NULL) ? fieldType->name : "NULL");
    int fieldTypeIndex = getIndexFromTypeDescriptor(fieldType);
    if ((fieldTypeIndex < 0) || (fieldTypeIndex > typeBytesNoCopyIndex)) {
      printLog(ERR, "Invalid field type.\n");
      query = bytesDestroy(query);
      returnValue = false;
      printLog(TRACE,
        "EXIT sqlAddRecordVargs(database=%p, dbName=\"%s\", tableName=\"%s\") "
        "= {%s}\n", database, dbName, tableName,
        (returnValue == true) ? "record added" : "record NOT added");
      dbName = stringDestroy(dbName);
      return returnValue;
    }
    
    if (fieldValue != NULL) {
      Bytes escapedValue = NULL;
      if (fieldTypeIndex <= typeLongDoubleIndex) {
        // Numeric value.  Convert to string and use the literal.
        char *stringValue = fieldType->toString(fieldValue);
        bytesAddStr(&escapedValue, stringValue);
        stringValue = stringDestroy(stringValue);
      } else if (fieldTypeIndex <= typeStringCiNoCopyIndex) {
        escapedValue = database->makeStringLiteral(str(fieldValue));
      } else { // fieldTypeIndex <= typeBytesNoCopyIndex
        escapedValue = database->makeBytesLiteral((Bytes) fieldValue);
      }
      bytesAddBytes(&query, escapedValue);
      escapedValue = bytesDestroy(escapedValue);
    } else {
      bytesAddStr(&query, "NULL");
    }
    fieldValue = va_arg(args, void*);
    if (fieldIndex < numFields - 1) {
      bytesAddStr(&query, ", ");
    }
  }
  bytesAddStr(&query, ");");
  queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlAddRecordVargs(database=%p, dbName=\"%s\", tableName=\"%s\") "
    "= {record %sadded}\n", database, dbName, tableName,
    (returnValue == true) ? "" : "NOT ");
  dbName = stringDestroy(dbName);
  return returnValue;
}

/// @fn bool sqlAddTableVargs(SqlDatabase *database, const char *dbString, const char *tableName, const char *primaryKey, va_list args)
///
/// @brief Add a new table to a database.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database to add a table to.
/// @param tableName The name of the table to add.
/// @param primaryKey The name of the primary key, or a comma-separated string
///  of field names to use as the primary key.
/// @param args A va_list of C strings.  The values are position dependent and
///   specify the full field definitions of the specified table.  The parameters
///   are terminated by a NULL pointer.
///
/// @return True on success, false on failure.
bool sqlAddTableVargs(SqlDatabase *database, const char *dbString,
  const char *tableName, const char *primaryKey, va_list args
) {
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE,
    "ENTER sqlAddTableVargs(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "primaryKey=\"%s\")\n", database, dbName, tableName, primaryKey);
  
  Bytes query = NULL;
  DbResult *queryResult = NULL;
  bool returnValue = false;
  
  bytesAddStr(&query, "create table ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  bytesAddStr(&query, "(");
  char *fieldArg = va_arg(args, char*);
  while (fieldArg != NULL) {
    // Field names in new table should NOT be escaped
    bytesAddStr(&query, fieldArg);
    bytesAddStr(&query, " ");
    
    // Get the type.
    void *type = va_arg(args, void*);
    if (type == NULL) {
      printLog(ERR, "Invalid NULL type.  Cannot add table.\n");
      query = bytesDestroy(query);
      printLog(TRACE,
        "EXIT sqlAddTableVargs(database=%p, dbName=\"%s\", tableName=\"%s\", "
        "primaryKey=\"%s\") = {table NOT added to database}\n",
        database, dbName, tableName, primaryKey);
      dbName = stringDestroy(dbName);
      return returnValue;
    }
    char *typeName
      = (char*) typeDescriptorToSqlTypeName((TypeDescriptor*) type);
    bool typeNameAllocated = false;
    if (typeName == NULL) {
      // type is non-NULL and not a type.  It is a string holding the number of
      // characters for the field.
      straddstr(&typeName, "VARCHAR(");
      straddstr(&typeName, (char*) type);
      straddstr(&typeName, ")");
      typeNameAllocated = true;
    }
    bytesAddStr(&query, typeName);
    if (typeNameAllocated) {
      typeName = stringDestroy(typeName);
    }
    bytesAddStr(&query, ", ");
    
    fieldArg = va_arg(args, char*);
  }
  bytesAddStr(&query, "primary key(");
  bytesAddStr(&query, primaryKey);
  bytesAddStr(&query, "));");
  queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlAddTableVargs(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "primaryKey=\"%s\") = {table %sadded to database}\n",
    database, dbName, tableName, primaryKey,
    (returnValue == true) ? "" : "NOT ");
  dbName = stringDestroy(dbName);
  return returnValue;
}

/// @fn bool sqlDeleteRecordsVargs(SqlDatabase *database, const char *dbString, const char *tableName, va_list args)
///
/// @brief Delete a record from a table in the database.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database in which to delete a record.
/// @param tableName The name of the table in which to delete a record.
/// @param args A va_list of C string pairs.  The first of the two strings is
///   the name of the field to match and the next string is the value desired
///   for that field in the query.  The qurey is terminated by a NULL pointer.
///
/// @return True on success or false on failure.
bool sqlDeleteRecordsVargs(SqlDatabase *database, const char *dbString,
  const char *tableName, va_list args
) {
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE, "ENTER sqlDeleteRecordsVargs(dbName=\"%s\", tableName=\"%s\"))\n",
    dbName, tableName);
  
  bool returnValue = false;
  Bytes query = NULL;
  
  void *fieldArg = va_arg(args, char*);
  
  int typeLongDoubleIndex = getIndexFromTypeDescriptor(typeLongDouble);
  int typeStringCiNoCopyIndex = getIndexFromTypeDescriptor(typeStringCiNoCopy);
  int typeBytesNoCopyIndex = getIndexFromTypeDescriptor(typeBytesNoCopy);
  
  bytesAddStr(&query, "delete from ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  if (fieldArg != NULL) {
    bytesAddStr(&query, " where ");
  }
  while (fieldArg != NULL) {
    bytesAddStr(&query, str(fieldArg));
    bytesAddStr(&query, "=");
    
    TypeDescriptor *fieldType
      = sqlGetFieldTypeByName(database, dbString, tableName, str(fieldArg));
    printLog(DEBUG, "Field (%s, %s, %s) is of type \"%s\".\n",
      dbString, tableName, str(fieldArg),
      (fieldType != NULL) ? fieldType->name : "NULL");
    fieldArg = va_arg(args, void*);
    int fieldTypeIndex = getIndexFromTypeDescriptor(fieldType);
    if ((fieldTypeIndex < 0) || (fieldTypeIndex > typeBytesNoCopyIndex)) {
      printLog(ERR, "Invalid field type.\n");
      query = bytesDestroy(query);
      returnValue = false;
      printLog(TRACE,
        "EXIT sqlDeleteRecordsVargs(database=%p, dbName=\"%s\", tableName=\"%s\") "
        "= {%s}\n", database, dbName, tableName,
        (returnValue == true) ? "records deleted" : "records NOT deleted");
      dbName = stringDestroy(dbName);
      return returnValue;
    }
    
    if (fieldArg != NULL) {
      Bytes escapedValue = NULL;
      if (fieldTypeIndex <= typeLongDoubleIndex) {
        // Numeric value.  Convert to string and use the literal.
        char *stringValue = fieldType->toString(fieldArg);
        bytesAddStr(&escapedValue, stringValue);
        stringValue = stringDestroy(stringValue);
      } else if (fieldTypeIndex <= typeStringCiNoCopyIndex) {
        escapedValue = database->makeStringLiteral(str(fieldArg));
      } else { // fieldTypeIndex <= typeBytesNoCopyIndex
        escapedValue = database->makeBytesLiteral((Bytes) fieldArg);
      }
      bytesAddBytes(&query, escapedValue);
      escapedValue = bytesDestroy(escapedValue);
    } else {
      bytesAddStr(&query, "NULL");
    }
    fieldArg = va_arg(args, void*);
    if (fieldArg != NULL) {
      bytesAddStr(&query, " and ");
    }
  }
  bytesAddStr(&query, ";");
  printLog(DEBUG, "Running query \"%s\"\n", query);
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlDeleteRecordsVargs(database=%p, dbName=\"%s\", tableName=\"%s\") "
    "= {record %s deleted}\n", database, dbName, tableName,
    (returnValue == true) ? "" : "NOT ");
  dbName = stringDestroy(dbName);
  return returnValue;
}

/// @fn Bytes dictionaryToQuery(SqlDatabase *database, const char *dbString, const char *tableName, const Dictionary *dict, const char *operation)
///
/// @brief Convert a dictionary (and it's other metadata) to a query that can
/// be run against the SQL instance.
///
/// @param dbString The name of the database in which to update a record.
/// @param tableName The name of the table in which to update a record.
/// @param dict A Dictionary containing key/value pairs where the keys are the
///   names of the columns and the values are the new values to store.
/// @param operation The operation to perform ("replace" or "insert").
/// 
/// @return Returns a pointer to a new Bytes object representing the
/// appropriate query on success, NULL on failure.
Bytes dictionaryToQuery(SqlDatabase *database, const char *dbString,
  const char *tableName, const Dictionary *dict, const char *operation
) {
  printLog(TRACE,
    "ENTER dictionaryToQuery(dbString=\"%s\", tableName=\"%s\", "
    "dict=%p, operation=\"%s\")\n",
    dbString, tableName, dict, operation);
  
  if ((dbString == NULL) || (tableName == NULL) || (dict == NULL)) {
    printLog(ERR, "One or more NULL parameters provided.\n");
    printLog(TRACE,
      "EXIT dictionaryToQuery(dbString=%p, tableName=%p, "
      "dict=%p, operation=\"%s\") = {NULL}\n",
      dbString, tableName, dict, operation);
    return NULL;
  }
  if ((dict->keyType != typeString) && (dict->keyType != typeStringNoCopy)
    && (dict->keyType != typeBytes) && (dict->keyType != typeBytesNoCopy)
  ) {
    // This is not a valid case.  Field names have to be something resembling
    // a string.
    printLog(ERR, "Key type \"%s\" is not a valid type.\n",
      dict->keyType->name);
    printLog(ERR,
      "Please use a dictionary with either typeBytes or typeString keys.\n");
    printLog(TRACE,
      "EXIT dictionaryToQuery(dbString=\"%s\", tableName=\"%s\", "
      "dict=%p, operation=\"%s\") = {NULL}\n",
      dbString, tableName, dict, operation);
    return NULL;
  }
  
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  Bytes query = NULL;
  Bytes values = NULL;
  // Build the query.
  bytesAddStr(&query, operation);
  bytesAddStr(&query, " into ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  bytesAddStr(&query, " (");
  bytesAddStr(&values, "values(");
  for (DictionaryEntry *entry = dict->head;
    entry != NULL;
    entry = entry->next
  ) {
    if ((dict->keyType == typeString) || (dict->keyType == typeStringNoCopy)) {
      // The expected case.
      if (!dbIsFieldNameValid((char*) entry->key)) {
        // Key contains invalid characters.
        printLog(ERR, "Key \"%s\" is invalid.\n", (char*) entry->key);
        query = bytesDestroy(query);
        values = bytesDestroy(values);
        printLog(TRACE,
          "EXIT dictionaryToQuery(dbName=\"%s\", tableName=\"%s\", "
          "dict=%p, operation=\"%s\") = {NULL}\n",
          dbName, tableName, dict, operation);
        dbName = stringDestroy(dbName);
        return NULL;
      }
    } else {
      // dict->keyType == typeBytes or typeBytesNoCopy since we threw out
      // everything else above. A little more clumsy to work with, but doable.
      if (!dbIsFieldNameValid((char*) entry->key)) {
        // Key contains invalid characters.
        printLog(ERR, "Key \"%s\" is invalid.\n", (char*) entry->key);
        query = bytesDestroy(query);
        values = bytesDestroy(values);
        printLog(TRACE,
          "EXIT dictionaryToQuery(dbName=\"%s\", tableName=\"%s\", "
          "dict=%p, operation=\"%s\") = {NULL}\n",
          dbName, tableName, dict, operation);
        dbName = stringDestroy(dbName);
        return NULL;
      }
    }
    
    if ((dict->keyType == typeString) || (dict->keyType == typeStringNoCopy)) {
      // The expected case.
      bytesAddStr(&query, (char*) entry->key);
    } else {
      // dict->keyType == typeBytes or typeBytesNoCopy since we threw out
      // everything else above.
      bytesAddBytes(&query, (Bytes) entry->key);
    }
    
    if ((entry->type == typeString) || (entry->type == typeStringNoCopy)
      || (entry->type == typeBytes) || (entry->type == typeBytesNoCopy)
    ) {
      if ((entry->type == typeString) || (entry->type == typeStringNoCopy)) {
        // The expected case.
        Bytes escapedArg = database->makeStringLiteral((char*) entry->value);
        bytesAddBytes(&values, escapedArg);
        escapedArg = bytesDestroy(escapedArg);
      } else { // typeBytes or tybeBytesNoCopy
        Bytes escapedArg = database->makeBytesLiteral((Bytes) entry->value);
        bytesAddBytes(&values, escapedArg);
        escapedArg = bytesDestroy(escapedArg);
      }
    } else {
      // Numeric value.  Don't quote.  Convert to string.
      char *valueString = entry->type->toString(entry->value);
      if ((valueString != NULL) && (*valueString != '\0')) {
        // The expected case.
        bytesAddStr(&values, valueString);
      } else {
        bytesAddStr(&values, "NULL");
      }
      valueString = stringDestroy(valueString);
    }
    
    if (entry->next != NULL) {
      bytesAddStr(&query, ", ");
      bytesAddStr(&values, ", ");
    }
  }
  bytesAddStr(&query, ") ");
  bytesAddBytes(&query, values);
  values = bytesDestroy(values);
  // The 'values(' was never terminated with a closing parenthesis, so close it.
  bytesAddStr(&query, ");");
  printLog(DEBUG, "Generated query: %s\n", (char*) query);
  
  printLog(TRACE,
    "EXIT dictionaryToQuery(dbName=\"%s\", tableName=\"%s\", "
    "dict=%p, operation=\"%s\") = {%p}\n",
    dbName, tableName, dict, operation, query);
  dbName = stringDestroy(dbName);
  return query;
}

/// @fn bool sqlUpdateRecordDict(SqlDatabase *database, const char *dbString, const char *tableName, Dictionary *dict)
///
/// @brief Update the contents of a record in the database.
///
/// @details This function replaces an existing record in the database with
///   a new one specified by the extra parameters in this function.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database in which to update a record.
/// @param tableName The name of the table in which to update a record.
/// @param dict A Dictionary containing key/value pairs where the keys are the
///   names of the columns and the values are the new values to store.
///
/// @return True on success, false on failure.
bool sqlUpdateRecordDict(SqlDatabase *database,
  const char *dbString, const char *tableName,
  Dictionary *dict
) {
  printLog(TRACE,
    "ENTER sqlUpdateRecordDict(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "dict=%p)\n", database, dbString, tableName, dict);
  
  // dictionaryToQuery will do all the argument checking.  No point in doing it
  // multiple times.
  Bytes query = dictionaryToQuery(database, dbString, tableName, dict, "replace");
  if (query == NULL) {
    printLog(ERR, "Could not construct query from dictionary.\n");
    printLog(TRACE,
      "EXIT sqlUpdateRecordDict(database=%p, dString=\"%s\", tableName=\"%s\", "
      "dict=%p) = {%s}\n", database, dbString, tableName, dict,
      "record NOT updated");
    return false;
  }
  
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  bool returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlUpdateRecordDict(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "dict=%p) = {%s}\n", database, dbString, tableName, dict,
    (returnValue == true) ? "record updated" : "record NOT updated");
  return returnValue;
}

/// @fn bool sqlAddRecordDict(SqlDatabase *database, const char *dbString, const char *tableName, Dictionary *dict)
///
/// @brief Add a new record to a table in a database.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database the table is in.
/// @param tableName The name of the table to add a record to.
/// @param dict A Dictionary containing key/value pairs where the keys are the
///   names of the columns and the values are the new values to store.
///
/// @return True on success, false on failure.
bool sqlAddRecordDict(SqlDatabase *database,
  const char *dbString, const char *tableName,
  Dictionary *dict
) {
  printLog(TRACE,
    "ENTER sqlAddRecordDict(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "dict=%p)\n", database, dbString, tableName, dict);
  
  // dictionaryToQuery will do all the argument checking.  No point in doing it
  // multiple times.
  Bytes query = dictionaryToQuery(database, dbString, tableName, dict, "insert");
  if (query == NULL) {
    printLog(ERR, "Could not construct query from dictionary.\n");
    printLog(TRACE,
      "EXIT sqlAddRecordDict(database=%p, dbString=\"%s\", tableName=\"%s\", "
      "dict=%p) = {%s}\n", database, dbString, tableName, dict,
      "record NOT added");
    return false;
  }
  
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  bool returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlAddRecordDict(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "dict=%p) = {%s}\n", database, dbString, tableName, dict,
    (returnValue == true) ? "record added" : "record NOT added");
  return returnValue;
}

/// @fn DbResult* sqlGetValuesLikeVargs(SqlDatabase *database, const char *dbString, const char *tableName, const char *select, const char *orderBy, va_list args)
///
/// @brief Low-level method for retrieving values from a table in a database
/// similar to the criteria.
///
/// @details This is a support function intented to only be called from other
///   parts of this library.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database to qurey.
/// @param tableName The name of the table to query.
/// @param select The name of the field to examine.
/// @param orderBy The field(s) to order by, if any.  This parameter may be
///   NULL.
/// @param args The representation of the query.
///
/// @return A DbResult with the results of the query.
DbResult* sqlGetValuesLikeVargs(SqlDatabase *database,
  const char *dbString, const char *tableName,
  const char *select, const char *orderBy, va_list args
) {
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE,
    "ENTER sqlGetValuesLikeVargs(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "select=\"%s\", orderBy=\"%s\")\n",
    database, dbName, tableName, select, (orderBy != NULL) ? orderBy : "");
  
  Bytes query = NULL;
  DbResult *queryResult = NULL;
  DbResult *returnValue = (DbResult*) calloc(1, sizeof(DbResult));
  if (returnValue == NULL) {
    LOG_MALLOC_FAILURE();
    exit(1);
  }
  
  bytesAddStr(&query, "select ");
  bytesAddStr(&query, select);
  bytesAddStr(&query, " from ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  char *fieldArg = va_arg(args, char*);
  if (fieldArg != NULL) {
    printLog(DEBUG, "Adding \"%s\"\n", fieldArg);
    bytesAddStr(&query, " where ");
  }
  while (fieldArg != NULL) {
    if (!dbIsFieldNameValid(fieldArg)) {
      query = bytesDestroy(query);
      printLog(ERR, "Invalid characters in argument \"%s\".\n", fieldArg);
      printLog(TRACE, "EXIT sqlGetValuesLikeVargs() = {0 results)\n");
      dbName = stringDestroy(dbName);
      return returnValue; // Empty result
    }
    bytesAddStr(&query, fieldArg);
    bytesAddStr(&query, " like ");
    fieldArg = va_arg(args, char*);
    if (fieldArg != NULL) {
      printLog(DEBUG, "Adding \"%s\"\n", fieldArg);
      // Convert instances of '*' wildcard character to SQL's '%' wildcard.
      Bytes stringLiteral = database->makeStringLiteral(fieldArg);
      Bytes escapedArg = bytesReplaceStr(stringLiteral, "\\*", "%");
      stringLiteral = bytesDestroy(stringLiteral);
      printLog(DEBUG, "Escaped string\n");
      bytesAddStr(&query, (char*) escapedArg);
      escapedArg = bytesDestroy(escapedArg);
      fieldArg = va_arg(args, char*);
      if (fieldArg != NULL) {
        bytesAddStr(&query, " and ");
      }
    } else {
      bytesAddStr(&query, "''");
    }
  }
  if (orderBy != NULL) {
    bytesAddStr(&query, " order by ");
    bytesAddStr(&query, orderBy);
  }
  bytesAddStr(&query, ";");
  printLog(DEBUG, "Running query \"%s\"\n", query);
  queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  printLog(DEBUG, "Got %llu query results \n", llu(queryResult->numResults));
  
  returnValue = dbFreeResult(returnValue);
  returnValue = queryResult;
  
  if (returnValue->numFields > 0) {
    sqlEnsureFieldTypes(database, dbString, tableName, returnValue);
  } else if ((returnValue->successful == true)
    && (returnValue->numFields == 0)
  ) {
    // This isn't a valid state.  We issued a select statement that was
    // successful but returned no fields.  That means the whole result is empty.
    // Fix this.
    returnValue
      = _sqlFixMissingFields(returnValue, database, dbString, tableName, select);
  }
  
  printLog(TRACE,
    "EXIT sqlGetValuesLikeVargs(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "select=\"%s\", orderBy=\"%s\") = {%llu results}\n",
    database, dbName, tableName, select, (orderBy != NULL) ? orderBy : "",
    llu(returnValue->numResults));
  dbName = stringDestroy(dbName);
  return returnValue;
}

/// @fn bool sqlAddTableList(SqlDatabase *database, const char *dbString, const char *tableName, const char *primaryKey, List *args)
///
/// @brief Add a new table to a database using a data structure.  Order of
/// arguments matters here, so we use a data structure that maintains order
/// (i.e. a list) instead of a dictionary, which could have arbitrary order.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database to add a table to.
/// @param tableName The name of the table to add.
/// @param primaryKey The name of the primary key, or a comma-separated string
///   of field names to use as the primary key.
/// @param args The list that contains the fields to add to the table.  The keys
///   of the list are the names of the fields, the values are TypeDescriptor
///   pointers or strings indicating the number of characters to have for the
///   value.
///
/// @return true on success or false on failure.
bool sqlAddTableList(SqlDatabase *database,
  const char *dbString, const char *tableName, const char *primaryKey,
  List *args
) {
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE,
    "ENTER sqlAddTableList(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "primaryKey=\"%s\", args=%p)\n", database, dbName, tableName, primaryKey,
    args);
  
  Bytes query = NULL;
  bool returnValue = false;
  
  bytesAddStr(&query, "create table ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  bytesAddStr(&query, "(");
  for (ListNode *node = args->head; node != NULL; node = node->next) {
    bytesAddStr(&query, (char*) node->key);
    bytesAddStr(&query, " ");
    
    void *type = (void*) node->value;
    char *typeName
      = (char*) typeDescriptorToSqlTypeName((TypeDescriptor*) type);
    bool typeNameAllocated = false;
    if (typeName == NULL) {
      // type is non-NULL and not a type.  It is a string holding the number of
      // characters for the field.
      straddstr(&typeName, "VARCHAR(");
      straddstr(&typeName, (char*) type);
      straddstr(&typeName, ")");
      typeNameAllocated = true;
    }
    bytesAddStr(&query, typeName);
    if (typeNameAllocated) {
      typeName = stringDestroy(typeName);
    }
    bytesAddStr(&query, ", ");
  }
  if ((primaryKey != NULL) && (*primaryKey != '\0')) {
    bytesAddStr(&query, "primary key(");
    bytesAddStr(&query, primaryKey);
    bytesAddStr(&query, ")");
  }
  bytesAddStr(&query, ");");
  
  printLog(DEBUG, "Running query \"%s\"\n", str(query));
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlAddTableList(database=%p, dbName=\"%s\", tableName=\"%s\", "
    "primaryKey=\"%s\", args=%p) = {%s}\n",
    database, dbName, tableName, primaryKey, args,
    (returnValue == true) ? "table added to database"
      : "table NOT added to database");
  dbName = stringDestroy(dbName);
  return returnValue;
}

/// @fn bool sqlDeleteTable(SqlDatabase *database, const char *dbString, const char *tableName)
///
/// @brief Get the names of the tables in a database.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database to use.
/// @param tableName The name of the table to delete (drop).
///
/// @return Returns true if the operation succeeded, false otherwise.
bool sqlDeleteTable(SqlDatabase *database,
  const char *dbString, const char *tableName
) {
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE,
    "ENTER sqlDeleteTable(database=%p, dbName=\"%s\", tableName=\"%s\")\n",
    database, dbName, tableName);
  
  Bytes query = NULL;
  bool returnValue = false;
  
  bytesAddStr(&query, "drop table ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  bytesAddStr(&query, ";");
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlDeleteTable(database=%p, dbName=\"%s\", tableName=\"%s\") = {%s}\n",
    database, dbName, tableName, (returnValue == true) ? "true" : "false");
  dbName = stringDestroy(dbName);
  return returnValue;
}

/// @fn bool sqlDeleteRecordsLikeVargs(SqlDatabase *database, const char *dbString, const char *tableName, va_list args)
///
/// @brief Low-level method for retrieving values from a table in a database
/// similar to the criteria.
///
/// @details This is a support function intented to only be called from other
///   parts of this library.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database to qurey.
/// @param tableName The name of the table to query.
/// @param args A va_list of key/value paris with the first of the two being
/// the key (name of the column) and the second of the two being the value.
///
/// @return A DbResult with the results of the query.
bool sqlDeleteRecordsLikeVargs(SqlDatabase *database,
  const char *dbString, const char *tableName, va_list args
) {
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE,
    "ENTER sqlDeleteRecordsLikeVargs(database=%p, dbName=\"%s\", "
    "tableName=\"%s\")\n",
    database, dbName, tableName);
  
  Bytes query = NULL;
  DbResult *queryResult = (DbResult*) calloc(1, sizeof(DbResult));
  if (queryResult == NULL) {
    LOG_MALLOC_FAILURE();
    exit(1);
  }
  bool returnValue = false;
  
  bytesAddStr(&query, "delete from ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  char *fieldArg = va_arg(args, char*);
  if (fieldArg != NULL) {
    printLog(DEBUG, "Adding \"%s\"\n", fieldArg);
    bytesAddStr(&query, " where ");
  }
  while (fieldArg != NULL) {
    bytesAddStr(&query, fieldArg);
    bytesAddStr(&query, " like ");
    fieldArg = va_arg(args, char*);
    if (fieldArg != NULL) {
      printLog(DEBUG, "Adding \"%s\"\n", fieldArg);
      if (!dbIsFieldNameValid(fieldArg)) {
        query = bytesDestroy(query);
        printLog(ERR, "Invalid characters in argument \"%s\".\n", fieldArg);
        printLog(TRACE, "EXIT sqlDeleteRecordsLikeVargs() = {false)\n");
        return false; // Empty result
      }
      // Convert instances of '*' wildcard character to SQL's '%' wildcard.
      Bytes stringLiteral = database->makeStringLiteral(fieldArg);
      Bytes escapedArg = bytesReplaceStr(stringLiteral, "\\*", "%");
      stringLiteral = bytesDestroy(stringLiteral);
      printLog(DEBUG, "Escaped string\n");
      bytesAddStr(&query, (char*) escapedArg);
      escapedArg = bytesDestroy(escapedArg);
      fieldArg = va_arg(args, char*);
      if (fieldArg != NULL) {
        bytesAddStr(&query, " and ");
      }
    } else {
      bytesAddStr(&query, "''");
    }
  }
  bytesAddStr(&query, ";");
  printLog(DEBUG, "Running query \"%s\"\n", query);
  queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  printLog(DEBUG, "Got %llu query results \n", llu(queryResult->numResults));
  
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlDeleteRecordsLikeVargs(database=%p, dbName=\"%s\", tableName=\"%s\") "
    "= {%s}\n",
    database, dbName, tableName, (returnValue == true) ? "true" : "false");
  dbName = stringDestroy(dbName);
  return returnValue;
}

/// @fn bool sqlUpdateResultVargs(const DbResult *dbResult, u64 resultIndex, va_list args)
///
/// @brief Update a record in the database given a previous DbResult and the
/// new parameters and values desired.
///
/// @param dbResult The result from a previous query.
/// @param resultIndex The zero-based result index of dbResult to update.
/// @param args A va_list of C string pairs.  The first of the two strings is
///   the name of the field to update and the next string is the new value
///   desired for that field.  The qurey is terminated by a NULL pointer.
///
/// @return Returns true if the generated query was successful, false if not.
bool sqlUpdateResultVargs(const DbResult *dbResult, u64 resultIndex,
  va_list args
) {
  printLog(TRACE,
    "ENTER sqlUpdateResultVargs(dbName=\"%s\", tableName=\"%s\", resultIndex=%llu)\n",
    dbResult->dbName, dbResult->tableName, llu(resultIndex));
  
  bool returnValue = false;
  
  if (resultIndex >= dbResult->numResults) {
    printLog(WARN, "resultIndex out of range for DbResult.\n");
    printLog(TRACE,
      "EXIT sqlUpdateResultVargs(dbName=\"%s\", tableName=\"%s\", resultIndex=%llu) "
      "= {%s}\n", dbResult->dbName, dbResult->tableName, llu(resultIndex), "false");
    return false;
  } else if (dbResult->numFields == 0) {
    printLog(WARN, "Invalid DbResult provided.\n");
    printLog(TRACE,
      "EXIT sqlUpdateResultVargs(dbName=\"%s\", tableName=\"%s\", resultIndex=%llu) "
      "= {%s}\n", dbResult->dbName, dbResult->tableName, llu(resultIndex), "false");
    return false;
  } else if ((dbResult->dbName == NULL) || (dbResult->tableName == NULL)) {
    printLog(WARN, "NULL dbName or tableName.  Cannot update.\n");
    printLog(TRACE,
      "EXIT sqlUpdateResultVargs(dbName=\"%s\", tableName=\"%s\", resultIndex=%llu) "
      "= {%s}\n", dbResult->dbName, dbResult->tableName, llu(resultIndex), "false");
    return false;
  }
  
  SqlDatabase *database = (SqlDatabase*) dbResult->database->db;
  
  int typeLongDoubleIndex = getIndexFromTypeDescriptor(typeLongDouble);
  int typeStringCiNoCopyIndex = getIndexFromTypeDescriptor(typeStringCiNoCopy);
  int typeBytesNoCopyIndex = getIndexFromTypeDescriptor(typeBytesNoCopy);
  
  // Start the query string.
  Bytes query = NULL;
  bytesAddStr(&query, "update ");
  bytesAddStr(&query, dbResult->dbName);
  bytesAddStr(&query, (dbInstance == NULL) ? "" : dbInstance);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, dbResult->tableName);
  bytesAddStr(&query, " set ");
  
  // Compile all the values we need to set.
  int numValuesSet = 0;
  char *fieldName = va_arg(args, char*);
  if (fieldName != NULL) {
    printLog(DEBUG, "Adding \"%s\"\n", fieldName);
  }
  while (fieldName != NULL) {
    TypeDescriptor *fieldType = sqlGetFieldTypeByName(database,
      dbResult->dbName, dbResult->tableName, fieldName);
    int fieldTypeIndex = getIndexFromTypeDescriptor(fieldType);
    if ((fieldTypeIndex < 0) || (fieldTypeIndex > typeBytesNoCopyIndex)) {
      printLog(ERR, "Invalid field type.\n");
      query = bytesDestroy(query);
      printLog(TRACE,
        "EXIT sqlUpdateResultVargs(dbName=\"%s\", tableName=\"%s\", "
        "resultIndex=%llu) = {%s}\n", dbResult->dbName, dbResult->tableName,
        llu(resultIndex), "false");
      return false;
    }
    printLog(DEBUG, "Field %s is type %s.\n", fieldName, fieldType->name);
    
    bytesAddStr(&query, fieldName);
    bytesAddStr(&query, "=");
    
    void *fieldValue = va_arg(args, void*);
    if (fieldValue != NULL) {
      Bytes escapedValue = NULL;
      if (fieldTypeIndex <= typeLongDoubleIndex) {
        // Numeric value.  Convert to string and use the literal.
        char *stringValue = fieldType->toString(fieldValue);
        bytesAddStr(&escapedValue, stringValue);
        stringValue = stringDestroy(stringValue);
      } else if (fieldTypeIndex <= typeStringCiNoCopyIndex) {
        escapedValue = database->makeStringLiteral((char*) fieldValue);
      } else { // fieldTypeIndex <= typeBytesNoCopyIndex
        escapedValue = database->makeBytesLiteral((Bytes) fieldValue);
      }
      printLog(DEBUG, "Setting %s='%s'\n", fieldName, (char*) escapedValue);
      bytesAddBytes(&query, escapedValue);
      escapedValue = bytesDestroy(escapedValue);
      numValuesSet++;
    } else {
      printLog(DEBUG, "Setting %s=NULL\n", fieldName);
      bytesAddStr(&query, "NULL");
      numValuesSet++;
    }
    fieldName = va_arg(args, char*);
    if (fieldName != NULL) {
      bytesAddStr(&query, ", ");
    }
  }
  
  if (numValuesSet == 0) {
    printLog(WARN, "sqlUpdateResultVargs called without update criteria.\n");
    printLog(TRACE,
      "EXIT sqlUpdateResultVargs(dbName=\"%s\", tableName=\"%s\", resultIndex=%llu) "
      "= {%s}\n", dbResult->dbName, dbResult->tableName, llu(resultIndex), "false");
    query = bytesDestroy(query);
    return false;
  }
  
  // Use the current values for the where clause.
  Bytes whereClause = NULL;
  const char **fieldNames = dbGetFieldNames(dbResult);
  u64 numFields = dbResult->numFields;
  for (u64 i = 0; i < numFields; i++) {
    void *value = dbGetResultByIndex(dbResult, resultIndex, i, NULL);
    if (value != NULL) {
      Bytes escapedValue = NULL;
      if (dbResult->fieldTypes[i] == typeBytes) {
        // Most values are expected to be of this type, so its case comes first.
        if (*((char*) value) != '\0') {
          escapedValue = database->makeBytesLiteral((Bytes) value);
        }
      } else if (dbResult->fieldTypes[i] == typeString) {
        if (*((char*) value) != '\0') {
          escapedValue = database->makeStringLiteral((char*) value);
        }
      } else {
        // Assume numerical value.
        escapedValue = dbResult->fieldTypes[i]->toBytes(value);
      }
      // TODO: At some point, I need to add support for date values, which
      // will be quoted like Bytes but don't need escaping (and may come from
      // the toString function of the field type like numerical values).
      
      if (escapedValue != NULL) {
        if (whereClause != NULL) {
          bytesAddStr(&whereClause, " and ");
        } else {
          bytesAddStr(&whereClause, " where ");
        }
        
        bytesAddStr(&whereClause, fieldNames[i]);
        bytesAddStr(&whereClause, "=");
        bytesAddBytes(&whereClause, escapedValue);
        escapedValue = bytesDestroy(escapedValue);
      }
    }
  }
  if (whereClause == NULL) {
    printLog(ERR, "No valid criteria in current result for record update.\n");
    printLog(TRACE,
      "EXIT sqlUpdateResultVargs(dbName=\"%s\", tableName=\"%s\", resultIndex=%llu) "
      "= {%s}\n", dbResult->dbName, dbResult->tableName, llu(resultIndex), "false");
    query = bytesDestroy(query);
    return false;
  }
  bytesAddBytes(&query, whereClause);
  whereClause = bytesDestroy(whereClause);
  
  bytesAddStr(&query, ";");
  printLog(DEBUG, "Running query \"%s\".\n", query);
  
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlUpdateResultVargs(dbName=\"%s\", tableName=\"%s\", resultIndex=%llu) "
    "= {%s}\n", dbResult->dbName, dbResult->tableName, llu(resultIndex),
    (returnValue == true) ? "true" : "false");
  return returnValue;
}

/// @fn DbResult* sqlQuery(SqlDatabase *database, const char *query)
///
/// @brief Method for running a raw SQL query against the database.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param query The SQL query to run.
///
/// @return A DbResult with the results of the query.
DbResult* sqlQuery(SqlDatabase *database, const char *query) {
  printLog(TRACE,
    "ENTER sqlQuery(database=%p, query=\"%s\")\n",
    database, query);
  
  DbResult *queryResult = (DbResult*) calloc(1, sizeof(DbResult));
  if (queryResult == NULL) {
    LOG_MALLOC_FAILURE();
    exit(1);
  }
  queryResult = database->stringQuery(database->connection, query);
  
  printLog(TRACE, "EXIT sqlQuery(query=\"%s\") = {%s, %llu results}\n", query,
    (queryResult->successful) ? "successful" : "failed", llu(queryResult->numResults));
  return queryResult;
}

/// @fn bool sqlLockTablesDict(SqlDatabase *database, const Dictionary *tablesToLock)
///
/// @brief Get a write lock in the database on the specified tables.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param tablesToLock A Dictionary (HashTable) where the keys are the names of
///   the tables to lock.  Values are ignored.  This function does *NOT* take
///   ownership of this data structure.  The caller must destroy it.
///
/// @return Returns true if the tables were locked successfully, false if not.
bool sqlLockTablesDict(SqlDatabase *database, const Dictionary *tablesToLock) {
  printLog(TRACE,
    "ENTER sqlLockTablesDict(database=%p, tablesToLock=%p)\n",
    database, tablesToLock);
  
  // Argument check.
  if ((database == NULL) || (tablesToLock == NULL)) {
    // Can't work with a NULL argument.
    printLog(TRACE,
      "EXIT sqlLockTablesDict(database=%p, tablesToLock=%p) = {unsuccessful}\n",
      database, tablesToLock);
    return false;
  } else if (tablesToLock->size == 0) {
    // Not an error per se, but nothing to do.
    printLog(WARN, "Zero-length Dictionary provided to sqlLockTablesDict.\n");
    printLog(TRACE,
      "EXIT sqlLockTablesDict(database=%p, tablesToLock=%p) = {successful}\n",
      database, tablesToLock);
    return false;
  }
  
  // Construct the query.
  Bytes queryString = NULL;
  for (HashNode *cur = tablesToLock->head; cur != NULL; cur = cur->next) {
    char *tableName = (char*) cur->key;
    if (*tableName == '@') {
      // This is metadata, not a table name.
      continue;
    }
    if (queryString != NULL) {
      bytesAddStr(&queryString, ", ");
    } else {
      bytesAddStr(&queryString, "lock tables ");
    }
    bytesAddStr(&queryString, tableName);
    bytesAddStr(&queryString, " write");
  }
  bytesAddStr(&queryString, ";");
  
  DbResult *queryResult = database->bytesQuery(database->connection, queryString);
  queryString = bytesDestroy(queryString);
  bool querySuccessful = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  if (!querySuccessful) {
    // Nothing else we can do here.
    // NOTE:  If lockedTables is not NULL, it will remain in it's current
    // state.  This query should never fail, so the system is already in
    // a bad state and keeping lockedTables as-is is desirable in this case.
    printLog(TRACE,
      "EXIT sqlLockTablesDict(database=%p, tablesToLock=%p) = {unsuccessful}\n",
      database, tablesToLock);
    return false;
  }
  
  printLog(TRACE,
    "EXIT sqlLockTablesDict(database=%p, tablesToLock=%p) = {successful}\n",
    database, tablesToLock);
  return querySuccessful;
}

/// @fn bool sqlUnlockTables(SqlDatabase *database, const Dictionary *tableLock)
///
/// @brief Unlock previously-locked tables and clear the cache of locked tables
/// for this thread.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param tableLock A pointer to a Dictionary returned by a previous call to
///   one of the sqlLockTables functions.
///
/// @return This function always returns NULL.
bool sqlUnlockTables(SqlDatabase *database, const Dictionary *tableLock) {
  printLog(TRACE,
    "ENTER sqlUnlockTables(database=%p, tableLock=%p)\n",
    database, tableLock);
  
  if ((database == NULL) || (tableLock == NULL)) {
    // Nothing to do.
    printLog(TRACE,
      "EXIT sqlUnlockTables(database=%p, tableLock=%p) = {NOT successful}\n",
      database, tableLock);
    return false;
  }
  
  DbResult *queryResult = database->stringQuery(database->connection, "unlock tables;");
  bool querySuccessful = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE, "EXIT sqlUnlockTables(database=%p, tableLock=%p) = {%s}\n",
    database, tableLock,
    (querySuccessful == true) ? "successful" : "NOT successful");
  return querySuccessful;
}

/// @fn bool sqlCommitTransaction(SqlDatabase *database)
///
/// @brief Commit an in-progress transaction for this thread in the database.
///
/// @note Transactions are managed by connection on the SQL server side and
/// connections are managed by thread on our side, so this commit will
/// only apply to transactions in progress on this thread.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
///
/// @return Returns true if committing the transaction was successful, false
/// if not.
bool sqlCommitTransaction(SqlDatabase *database) {
  printLog(TRACE, "ENTER sqlCommitTransaction(database=%p)\n", database);
  
  if (database == NULL) {
    // Nothing to do.
    printLog(TRACE,
      "EXIT sqlCommitTransaction(database=%p) = {NOT successful}\n",
      database);
    return false;
  }
  
  DbResult *queryResult = database->stringQuery(database->connection, "commit;");
  bool querySuccessful = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE, "EXIT sqlCommitTransaction(database=%p) = {%s}\n",
    database, (querySuccessful) ? "successful" : "NOT successful");
  return querySuccessful;
}

/// @fn bool sqlRollbackTransaction(SqlDatabase *database)
///
/// @brief Rollback an in-progress transaction for this thread in the database.
///
/// @note Transactions are managed by connection on the SQL server side and
/// connections are managed by threads on our side, so this rollback will
/// only apply to transactions in progress on this thread.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
///
/// @return Returns true if rolling back the transaction was successful, false
/// if not.
bool sqlRollbackTransaction(SqlDatabase *database) {
  printLog(TRACE, "ENTER sqlRollbackTransaction(database=%p)\n", database);
  
  if (database == NULL) {
    // Nothing to do.
    printLog(TRACE,
      "EXIT sqlRollbackTransaction(database=%p) = {NOT successful}\n",
      database);
    return false;
  }
  
  DbResult *queryResult = database->stringQuery(database->connection, "rollback;");
  bool querySuccessful = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE, "EXIT sqlRollbackTransaction(database=%p) = {%s}\n",
    database, (querySuccessful) ? "successful" : "NOT successful");
  return querySuccessful;
}

/// @fn bool sqlDeleteField(SqlDatabase *database, const char *dbString, const char *tableName, const char *fieldName)
///
/// @brief Remove a column from a table in a database.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database in the SqlDatabase to address.
/// @param tableName The name of the table to remove a field from.
/// @param fieldName The name of the field to remove from the table.
///
/// @return Returns true if removing the field from the table was successful,
/// false if not.
bool sqlDeleteField(SqlDatabase *database, const char *dbString,
  const char *tableName, const char *fieldName
) {
  printLog(TRACE,
    "ENTER sqlDeleteField(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "fieldName=\"%s\")\n", database, dbString, tableName, fieldName);
  
  if ((database == NULL) || (dbString == NULL) || (tableName == NULL)
    || (fieldName == NULL)
  ) {
    // Nothing to do.
    printLog(TRACE,
      "EXIT sqlDeleteField(database=%p, dbString=\"%s\", tableName=\"%s\", "
      "fieldName=\"%s\") = {NOT successful}\n",
      database, dbString, tableName, fieldName);
    return false;
  }
  
  Bytes dbName = NULL;
  bytesAddStr(&dbName, dbString);
  bytesAddStr(&dbName, dbInstance);
  
  Bytes query = NULL;
  abprintf(&query, "alter table %s.%s drop column %s;",
    str(dbName), tableName, fieldName);
  dbName = bytesDestroy(dbName);
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  bool querySuccessful = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  // Invalidate the cache.
  sqlInvalidateTableDescription(database, dbString, tableName);
  
  printLog(TRACE,
    "EXIT sqlDeleteField(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "fieldName=\"%s\") = {%s}\n",
    database, dbString, tableName, fieldName,
    (querySuccessful) ? "successful" : "NOT successful");
  return querySuccessful;
}

/// @fn bool sqlAddField(SqlDatabase *database, const char *dbString, const char *tableName, const char *afterField, const char *newField, void *type)
///
/// @brief Add a new field to an existing table in a database.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database in the SqlDatabase to address.
/// @param tableName The name of the table to add a field to.
/// @param afterField The name of the field in the existing table to place the
///   new field after.  If this value is an empty string, the new field will be
///   added at the beginning of the table.
/// @param newField The name of the new field to add.
/// @param type A TypeDescriptor defining the type of the new field
///   -OR- a character pointer holding the number of characters for the field.
///
/// @return Returns true if adding the field to the table was successful,
/// false if not.
bool sqlAddField(SqlDatabase *database, const char *dbString,
  const char *tableName, const char *afterField, const char *newField,
  void *type
) {
  printLog(TRACE,
    "ENTER sqlAddField(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "afterField=\"%s\", newField=\"%s\", type=%p)\n",
    database, dbString, tableName, afterField, newField, type);
  
  if ((database == NULL) || (dbString == NULL) || (tableName == NULL)
    || (afterField == NULL) || (newField == NULL) || (*newField == '\0')
    || (type == NULL)
  ) {
    // Nothing to do.
    printLog(TRACE,
      "EXIT sqlAddField(database=%p, dbString=\"%s\", tableName=\"%s\", "
      "afterField=\"%s\", newField=\"%s\", type=%p) = {NOT successful}\n",
      database, dbString, tableName, afterField, newField, type);
    return false;
  }
  
  char *typeName = (char*) typeDescriptorToSqlTypeName((TypeDescriptor*) type);
  bool typeNameAllocated = false;
  if (typeName == NULL) {
    // type is non-NULL and not a type.  It is a string holding the number of
    // characters for the field.
    straddstr(&typeName, "VARCHAR(");
    straddstr(&typeName, (char*) type);
    straddstr(&typeName, ")");
    typeNameAllocated = true;
  }
  
  Bytes dbName = NULL;
  bytesAddStr(&dbName, dbString);
  bytesAddStr(&dbName, dbInstance);
  
  Bytes query = NULL;
  if (*afterField != '\0') {
    // The usual case.
    abprintf(&query, "alter table %s.%s add column %s %s after %s;",
      str(dbName), tableName, newField, typeName, afterField);
  } else {
    // Insert the new column at the beginning of the table.
    abprintf(&query, "alter table %s.%s add column %s %s first;",
      str(dbName), tableName, newField, typeName);
  }
  dbName = bytesDestroy(dbName);
  if (typeNameAllocated) {
    typeName = stringDestroy(typeName);
  }
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  bool querySuccessful = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  // Invalidate the cache.
  sqlInvalidateTableDescription(database, dbString, tableName);
  
  printLog(TRACE,
    "EXIT sqlAddField(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "afterField=\"%s\", newField=\"%s\", type=%p) = {%s}\n",
    database, dbString, tableName, afterField, newField, type,
    (querySuccessful) ? "successful" : "NOT successful");
  return querySuccessful;
}

/// @fn bool sqlChangeFieldName(SqlDatabase *database, const char *dbString, const char *tableName, const char *oldName, const char *newName)
///
/// @brief Add a new field to an existing table in a database.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbString The name of the database in the SqlDatabase to address.
/// @param tableName The name of the table to add a field to.
/// @param oldName The name of the field to change.
/// @param newName The new name for the field.
///
/// @return Returns true if changing the name of the field was successful,
/// false if not.
bool sqlChangeFieldName(SqlDatabase *database, const char *dbString,
  const char *tableName, const char *oldName, const char *newName
) {
  printLog(TRACE,
    "ENTER sqlChangeFieldName(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "oldName=\"%s\", newName=\"%s\")\n",
    database, dbString, tableName, oldName, newName);
  
  if ((database == NULL) || (dbString == NULL) || (tableName == NULL)
    || (oldName == NULL) || (*oldName == '\0')
    || (newName == NULL) || (*newName == '\0')
  ) {
    // Nothing to do.
    printLog(TRACE,
      "EXIT sqlChangeFieldName(database=%p, dbString=\"%s\", tableName=\"%s\", "
      "oldName=\"%s\", newName=\"%s\") = {NOT successful}\n",
      database, dbString, tableName, oldName, newName);
    return false;
  }
  
  Bytes dbName = NULL;
  bytesAddStr(&dbName, dbString);
  bytesAddStr(&dbName, dbInstance);
  
  Bytes query = NULL;
  // Change the column's name.
  abprintf(&query, "alter table %s.%s rename column %s to %s;",
    str(dbName), tableName, oldName, newName);
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  bool querySuccessful = queryResult->successful;
  query = bytesDestroy(query);
  
  // Invalidate the cache.
  sqlInvalidateTableDescription(database, dbString, tableName);
  
  dbName = bytesDestroy(dbName);
  
  printLog(TRACE,
    "EXIT sqlChangeFieldName(database=%p, dbString=\"%s\", tableName=\"%s\", "
    "oldName=\"%s\", newName=\"%s\") = {%s}\n",
    database, dbString, tableName, oldName, newName,
    (querySuccessful) ? "successful" : "NOT successful");
  return querySuccessful;
}

/// @fn DbResult* sqlDescribeTable(SqlDatabase *sqlDatabase, const char *dbName, const char *tableName)
///
/// @brief Get a (field name, TypeDescriptor) description of a table.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query.
/// @param dbName The name of the database to query.
/// @param tableName The name of the table to describe.
///
/// @return Returns a populated DbResult with the information on success, an
/// unpopulated DbResult on failure.
DbResult* sqlDescribeTable(SqlDatabase *sqlDatabase, const char *dbName,
  const char *tableName
) {
  printLog(TRACE,
    "ENTER sqlDescribeTable(sqlDatabase=%p, dbName=\"%s\", "
    "tableName=\"%s\")\n", sqlDatabase, dbName, tableName);
  
  DbResult *returnValue = (DbResult*) calloc(1, sizeof(DbResult));
  if (returnValue == NULL) {
    LOG_MALLOC_FAILURE();
    exit(1);
  }
  
  if ((sqlDatabase == NULL) || (dbName == NULL) || (tableName == NULL)) {
    printLog(ERR, "Parameter is NULL.\n");
    printLog(TRACE,
      "EXIT sqlDescribeTable(sqlDatabase=%p, dbName=\"%s\", tableName=\"%s\") "
      "= {NOT successful}\n", sqlDatabase, dbName, tableName);
    return returnValue;
  }
  
  DbResult *tableDescription = sqlDatabase->describeTable(
    sqlDatabase->connection, dbName, tableName);
  
  if (tableDescription->successful == true) {
    returnValue = dbFreeResult(returnValue);
    returnValue = tableDescription;
  } else {
    tableDescription = dbFreeResult(tableDescription);
  }
  
  printLog(TRACE,
    "EXIT sqlDescribeTable(sqlDatabase=%p, dbName=\"%s\", tableName=\"%s\") "
    "= {%s}\n", sqlDatabase, dbName, tableName,
    (returnValue->successful == true) ? "successful" : "NOT successful");
  return returnValue;
}

/// @fn bool sqlAddRecords(void *database, const char *dbName, const char *tableName, const DbResult *dbResut)
///
/// @brief Add a group of records to a table in a database.
///
/// @param database A pointer to the SqlDatabase object representing the
///   database system to query cast to a void*.
/// @param dbName The name of the database the table is in.
/// @param tableName The name of the table to add a record to.
/// @param dbResult A DbResult that contains the records to add.
///
/// @return Returns true on success, false on failure.
bool sqlAddRecords(void *database,
  const char *dbName, const char *tableName, const DbResult *dbResult
) {
  printLog(TRACE,
    "ENTER sqlAddRecords(database=%p, dbName=\"%s\", tableName=\"%s\")\n",
    database, dbName, tableName);
  
  if ((database == NULL) || (dbName == NULL) || (tableName == NULL)) {
    printLog(ERR, "One or more NULL parameters.\n");
    printLog(TRACE,
      "EXIT sqlAddRecords(database=%p, dbName=\"%s\", tableName=\"%s\") "
      "= {NOT successful}\n", database, dbName, tableName);
    return false;
  } else if ((dbResult == NULL) || (dbResult->numResults == 0)) {
    // Not an error, but nothing to do.
    printLog(TRACE,
      "EXIT sqlAddRecords(database=%p, dbName=\"%s\", tableName=\"%s\") "
      "= {successful}\n", database, dbName, tableName);
    return true;
  }
  
  SqlDatabase *sqlDatabase = (SqlDatabase*) database;
  bool returnValue = false;
  DbResult *queryResult = NULL;
  
  Bytes query = NULL;
  
  int typeLongDoubleIndex = getIndexFromTypeDescriptor(typeLongDouble);
  int typeStringCiNoCopyIndex = getIndexFromTypeDescriptor(typeStringCiNoCopy);
  int typeBytesNoCopyIndex = getIndexFromTypeDescriptor(typeBytesNoCopy);
  
  returnValue = false;
  
  bytesAddStr(&query, "insert into ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, dbInstance);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  bytesAddStr(&query, " values ");
  
  u64 numResults = dbResult->numResults;
  u64 numFields = dbResult->numFields;
  TypeDescriptor **fieldTypes = dbResult->fieldTypes;
  for (u64 recordIndex = 0; recordIndex < numResults; recordIndex++) {
    bytesAddStr(&query, "(");
    for (u64 fieldIndex = 0; fieldIndex < numFields; fieldIndex++) {
      void *fieldValue
        = dbGetResultByIndex(dbResult, recordIndex, fieldIndex, NULL);
      TypeDescriptor *fieldType = fieldTypes[fieldIndex];
      printLog(DEBUG, "Field (%s, %s, %llu) is of type \"%s\".\n",
        dbName, tableName, llu(fieldIndex),
        (fieldType != NULL) ? fieldType->name : "NULL");
      int fieldTypeIndex = getIndexFromTypeDescriptor(fieldType);
      if ((fieldTypeIndex < 0) || (fieldTypeIndex > typeBytesNoCopyIndex)) {
        printLog(ERR, "Invalid field type.\n");
        query = bytesDestroy(query);
        returnValue = false;
        printLog(TRACE,
          "EXIT sqlAddRecords(database=%p, dbName=\"%s\", tableName=\"%s\") "
          "= {%s}\n", database, dbName, tableName,
          (returnValue == true) ? "record added" : "record NOT added");
        return returnValue;
      }
      
      if (fieldValue != NULL) {
        Bytes escapedValue = NULL;
        if (fieldTypeIndex <= typeLongDoubleIndex) {
          // Numeric value.  Convert to string and use the literal.
          char *stringValue = fieldType->toString(fieldValue);
          bytesAddStr(&escapedValue, stringValue);
          stringValue = stringDestroy(stringValue);
        } else if (fieldTypeIndex <= typeStringCiNoCopyIndex) {
          escapedValue = sqlDatabase->makeStringLiteral(str(fieldValue));
        } else { // fieldTypeIndex <= typeBytesNoCopyIndex
          escapedValue = sqlDatabase->makeBytesLiteral((Bytes) fieldValue);
        }
        bytesAddBytes(&query, escapedValue);
        escapedValue = bytesDestroy(escapedValue);
      } else {
        bytesAddStr(&query, "NULL");
      }
      
      if (fieldIndex < numFields - 1) {
        bytesAddStr(&query, ", ");
      }
    }
    bytesAddStr(&query, ")");
    
    if (recordIndex < numResults - 1) {
      bytesAddStr(&query, ", ");
    }
  }
  bytesAddStr(&query, ";");
  
  printLog(DEBUG, "Running query \"%s\"\n", str(query));
  queryResult = sqlDatabase->bytesQuery(sqlDatabase->connection, query);
  query = bytesDestroy(query);
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  if (returnValue == false) {
    // Bulk update failed.  Add what we can one-by-one.
    // NOTE:  This does not change the overall return value since we still
    // failed to add all the records, it just does a better job than giving
    // up completely.  Only the caller knows whether a partial success is
    // acceptable or not.
    for (u64 recordIndex = 0; recordIndex < numResults; recordIndex++) {
      bytesAddStr(&query, "insert into ");
      bytesAddStr(&query, dbName);
      bytesAddStr(&query, dbInstance);
      bytesAddStr(&query, ".");
      bytesAddStr(&query, tableName);
      bytesAddStr(&query, " values ");
      bytesAddStr(&query, "(");
      
      for (u64 fieldIndex = 0; fieldIndex < numFields; fieldIndex++) {
        void *fieldValue
          = dbGetResultByIndex(dbResult, recordIndex, fieldIndex, NULL);
        TypeDescriptor *fieldType = fieldTypes[fieldIndex];
        printLog(DEBUG, "Field (%s, %s, %llu) is of type \"%s\".\n",
          dbName, tableName, llu(fieldIndex),
          (fieldType != NULL) ? fieldType->name : "NULL");
        int fieldTypeIndex = getIndexFromTypeDescriptor(fieldType);
        if ((fieldTypeIndex < 0) || (fieldTypeIndex > typeBytesNoCopyIndex)) {
          printLog(ERR, "Invalid field type.\n");
          query = bytesDestroy(query);
          returnValue = false;
          printLog(TRACE,
            "EXIT sqlAddRecords(database=%p, dbName=\"%s\", tableName=\"%s\") "
            "= {%s}\n", database, dbName, tableName,
            (returnValue == true) ? "record added" : "record NOT added");
          return returnValue;
        }
        
        if (fieldValue != NULL) {
          Bytes escapedValue = NULL;
          if (fieldTypeIndex <= typeLongDoubleIndex) {
            // Numeric value.  Convert to string and use the literal.
            char *stringValue = fieldType->toString(fieldValue);
            bytesAddStr(&escapedValue, stringValue);
            stringValue = stringDestroy(stringValue);
          } else if (fieldTypeIndex <= typeStringCiNoCopyIndex) {
            escapedValue = sqlDatabase->makeStringLiteral(str(fieldValue));
          } else { // fieldTypeIndex <= typeBytesNoCopyIndex
            escapedValue = sqlDatabase->makeBytesLiteral((Bytes) fieldValue);
          }
          bytesAddBytes(&query, escapedValue);
          escapedValue = bytesDestroy(escapedValue);
        } else {
          bytesAddStr(&query, "NULL");
        }
        
        if (fieldIndex < numFields - 1) {
          bytesAddStr(&query, ", ");
        }
      }
      bytesAddStr(&query, ");");
      
      printLog(DEBUG, "Running query \"%s\"\n", str(query));
      queryResult = sqlDatabase->bytesQuery(sqlDatabase->connection, query);
      query = bytesDestroy(query);
      // We don't care about the success of the operation.  Our return value is
      // going to be false regardless of what was returned here.
      queryResult = dbFreeResult(queryResult);
    }
  }
  
  printLog(TRACE,
    "EXIT sqlAddRecords(database=%p, dbName=\"%s\", tableName=\"%s\") "
    "= {%s}\n", database, dbName, tableName,
    (returnValue == true) ? "successful" : "NOT successful");
  return returnValue;
}

/// @fn bool sqlRenameTable(SqlDatabase *database, const char *dbName, const char *oldTableName, const char *newTableName)
///
/// @brief Rename a table in a database.
///
/// @param database A pointer to a SqlDatabase object that manages the system.
/// @param dbName The name of the database in the SQL database.
/// @param oldTableName The name of the table as it exists in the database at
///   the time this call is made.
/// @param newTableName The deisred new name of the table.
///
/// @return Returns true on success, false on failure.
bool sqlRenameTable(SqlDatabase *database, const char *dbName,
  const char *oldTableName, const char *newTableName
) {
  bool returnValue = true;
  
  printLog(TRACE, "ENTER sqlRenameTable(database=%p, dbName=\"%s\", "
    "oldTableName=\"%s\", newTableName=\"%s\")\n",
    database, dbName, oldTableName, newTableName);
  
  if ((database == NULL) || (dbName == NULL)
    || (oldTableName == NULL) || (newTableName == NULL)
  ) {
    printLog(ERR, "One or more NULL parameters.\n");
    returnValue = false;
    printLog(TRACE, "EXIT sqlRenameTable(database=%p, dbName=\"%s\", "
      "oldTableName=\"%s\", newTableName=\"%s\") = {%s}\n",
      database, dbName, oldTableName, newTableName,
      (returnValue == true) ? "successful" : "NOT successful");
    return returnValue;
  }
  
  Bytes query = NULL;
  abprintf(&query, "alter table %s%s.%s rename to %s%s.%s;",
    dbName, (dbInstance != NULL) ? dbInstance : "", oldTableName,
    dbName, (dbInstance != NULL) ? dbInstance : "", newTableName);
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE, "EXIT sqlRenameTable(database=%p, dbName=\"%s\", "
    "oldTableName=\"%s\", newTableName=\"%s\") = {%s}\n",
    database, dbName, oldTableName, newTableName,
    (returnValue == true) ? "successful" : "NOT successful");
  return returnValue;
}

/// @fn int sqlCompare(void *db1, void *db2)
///
/// @brief Compare two SQL databases to see if they point to the same
/// connection.
///
/// @param db1 A pointer to the first SqlDatabase instance, cast to a void
///   pointer.
/// @param db2 A pointer to the second SqlDatabase instance, cast to a void
///   pointer.
///
/// @return Returns 0 if the two connections are identical, non-zero otherwise.
int sqlCompare(void *db1, void *db2) {
  SCOPE_ENTER("db1=%p, db2=%p", db1, db2);
  
  SqlDatabase *sqlDb1 = (SqlDatabase*) db1;
  SqlDatabase *sqlDb2 = (SqlDatabase*) db2;
  
  int returnValue = ((int) sqlDb1->sqlDbType) - ((int) sqlDb2->sqlDbType);
  if (returnValue == 0) {
    // The connections are of the same type, so the compare function is the same
    // on both pointers and we can use either one for the comparison operation.
    returnValue = sqlDb1->compare(sqlDb1->connection, sqlDb2->connection);
  }
  
  SCOPE_EXIT("db1=%p, db2=%p", "%d", db1, db2, returnValue);
  return returnValue;
}

/// @fn bool sqlUpdateFieldVargs(void *db, const char *dbName, const char *tableName, const char *fieldName, const void *newValue, va_list args)
///
/// @brief Update a field in a table with a new value where a set of criteria
/// is met.
///
/// @param db A pointr to a SqlDatabase object cast to a void pointer.
/// @param dbName The name of the database in the SqlDatabase to operate on.
/// @param tableName The name of the table in the database the field is in.
/// @param fieldName The name of the field to update.
/// @param newValue The desired new value for the field when the specified
///   conditions are met.
/// @param args A va_list of key-value pairs where the even indexes are the
///   names of the fields to match and the odd indexes are the values required
///   for those fields.
///
/// @return Returns true if the generated query was successful, false if not.
bool sqlUpdateFieldVargs(void *db, const char *dbName,
  const char *tableName, const char *fieldName, const void *newValue,
  va_list args
) {
  SCOPE_ENTER("db=%p, dbName=%s, tableName=%s, fieldName=%s, newValue=%s",
    db, strOrNull(dbName), strOrNull(tableName), strOrNull(fieldName),
    strOrNull(newValue));
  
  SqlDatabase *sqlDatabase = (SqlDatabase*) db;
  bool returnValue = false;
  
  if ((sqlDatabase == NULL) || (dbName == NULL) || (tableName == NULL)
    || (fieldName == NULL)
  ) {
    printLog(WARN, "One or more NULL parameters.  Cannot update.\n");
    SCOPE_EXIT(
      "db=%p, dbName=%s, tableName=%s, fieldName=%s, newValue=%s", "%s",
      db, strOrNull(dbName), strOrNull(tableName), strOrNull(fieldName),
      strOrNull(newValue), boolNames[returnValue]);
    return returnValue; // false
  }
  
  int typeLongDoubleIndex = getIndexFromTypeDescriptor(typeLongDouble);
  int typeBytesNoCopyIndex = getIndexFromTypeDescriptor(typeBytesNoCopy);
  
  // Start the query string.
  Bytes query = NULL;
  bytesAddStr(&query, "update ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, (dbInstance == NULL) ? "" : dbInstance);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  bytesAddStr(&query, " set ");
  bytesAddStr(&query, fieldName);
  bytesAddStr(&query, "=");
  
  TypeDescriptor *fieldType
    = sqlGetFieldTypeByName(sqlDatabase, dbName, tableName, fieldName);
  
  int fieldTypeIndex = getIndexFromTypeDescriptor(fieldType);
  if ((fieldTypeIndex < 0) || (fieldTypeIndex > typeBytesNoCopyIndex)) {
    printLog(ERR, "Invalid field type.\n");
    if (fieldTypeIndex > typeBytesNoCopyIndex) {
      printLog(ERR, "Got type \"%s\".\n", fieldType->name);
    }
    query = bytesDestroy(query);
    SCOPE_EXIT(
      "db=%p, dbName=%s, tableName=%s, fieldName=%s, newValue=%s", "%s",
      db, strOrNull(dbName), strOrNull(tableName), strOrNull(fieldName),
      strOrNull(newValue), boolNames[returnValue]);
    return returnValue; // false
  }
  
  if (newValue != NULL) {
    Bytes escapedValue = NULL;
    if (fieldTypeIndex <= typeLongDoubleIndex) {
      // Numeric value.  Convert to string and use the literal.
      char *stringValue = fieldType->toString(newValue);
      bytesAddStr(&escapedValue, stringValue);
      stringValue = stringDestroy(stringValue);
    } else { // fieldTypeIndex <= typeBytesNoCopyIndex
      escapedValue = sqlDatabase->makeStringLiteral((char*) newValue);
    }
    printLog(DEBUG, "Setting %s='%s'\n", fieldName, (char*) escapedValue);
    bytesAddBytes(&query, escapedValue);
    escapedValue = bytesDestroy(escapedValue);
  } else {
    printLog(DEBUG, "Setting %s=NULL\n", fieldName);
    bytesAddStr(&query, "NULL");
  }
  
  // Compile all the values we need to set.
  fieldName = va_arg(args, char*);
  if (fieldName != NULL) {
    bytesAddStr(&query, " where ");
    printLog(DEBUG, "Adding \"%s\"\n", fieldName);
  }
  while (fieldName != NULL) {
    fieldType
      = sqlGetFieldTypeByName(sqlDatabase, dbName, tableName, fieldName);
    int fieldTypeIndex = getIndexFromTypeDescriptor(fieldType);
    if ((fieldTypeIndex < 0) || (fieldTypeIndex > typeBytesNoCopyIndex)) {
      printLog(ERR, "Invalid field type.\n");
      query = bytesDestroy(query);
      SCOPE_EXIT(
        "db=%p, dbName=%s, tableName=%s, fieldName=%s, newValue=%s", "%s",
        db, strOrNull(dbName), strOrNull(tableName), strOrNull(fieldName),
        strOrNull(newValue), boolNames[returnValue]);
      return returnValue; // false
    }
    
    bytesAddStr(&query, fieldName);
    bytesAddStr(&query, "=");
    
    void *fieldValue = va_arg(args, void*);
    if (fieldValue != NULL) {
      Bytes escapedValue = NULL;
      if (fieldTypeIndex <= typeLongDoubleIndex) {
        // Numeric value.  Convert to string and use the literal.
        char *stringValue = fieldType->toString(fieldValue);
        bytesAddStr(&escapedValue, stringValue);
        stringValue = stringDestroy(stringValue);
      } else { // fieldTypeIndex <= typeBytesNoCopyIndex
        escapedValue = sqlDatabase->makeStringLiteral((char*) fieldValue);
      }
      printLog(DEBUG, "Setting %s='%s'\n", fieldName, (char*) escapedValue);
      bytesAddBytes(&query, escapedValue);
      escapedValue = bytesDestroy(escapedValue);
    } else {
      printLog(DEBUG, "Setting %s=NULL\n", fieldName);
      bytesAddStr(&query, "NULL");
    }
    fieldName = va_arg(args, char*);
    if (fieldName != NULL) {
      bytesAddStr(&query, " and ");
    }
  }
  
  bytesAddStr(&query, ";");
  printLog(DEBUG, "Running query \"%s\".\n", query);
  
  DbResult *queryResult
    = sqlDatabase->bytesQuery(sqlDatabase->connection, query);
  query = bytesDestroy(query);
  returnValue = queryResult->successful;
  queryResult = dbFreeResult(queryResult);
  
  SCOPE_EXIT(
    "db=%p, dbName=%s, tableName=%s, fieldName=%s, newValue=%s", "%s",
    db, strOrNull(dbName), strOrNull(tableName), strOrNull(fieldName),
    strOrNull(newValue), boolNames[returnValue]);
  return returnValue;
}

/// @fn TypeDescriptor* sqlGetFieldTypeByName(void *db, const char *dbName, const char *tableName, const char *fieldName)
///
/// @brief Get the type of a field in a table.
///
/// @param db A pointer to a SqlDatabase to query, cast to a void*.
/// @param dbName The name of the database in the system to query.
/// @param tableName The name of the table the field is in.
/// @param fieldName The name of the field to query.
///
/// @return Returns a pointer to the relevant TypeDescriptor on success, NULL
/// on failure.
TypeDescriptor* sqlGetFieldTypeByName(void *db,
  const char *dbName, const char *tableName, const char *fieldName
) {
  SqlDatabase *sqlDatabase = (SqlDatabase*) db;
  
  printLog(TRACE,
    "ENTER sqlGetFieldTypeByName(sqlDatabase=%p, dbName=%s, tableName=%s, "
    "fieldName=%s)\n", sqlDatabase, strOrNull(dbName), strOrNull(tableName),
    strOrNull(fieldName));
  
  TypeDescriptor *type = NULL;
  if ((sqlDatabase == NULL) || (sqlDatabase->tableDescriptions == NULL)) {
    printLog(ERR,
      "NULL sqlDatabase or sqlDatabase->tableDescriptions provided.\n");
    printLog(TRACE,
      "EXIT sqlGetFieldTypeByName(sqlDatabase=%p, dbName=%s, tableName=%s, "
      "fieldName=%s) = {%s}\n", sqlDatabase, strOrNull(dbName),
      strOrNull(tableName), strOrNull(fieldName),
      (type != NULL) ? type->name : "NULL");
    return type; // NULL
  }
  
  // Get the field types.
  Bytes lookupKey = NULL;
  bytesAddStr(&lookupKey, dbName);
  bytesAddStr(&lookupKey, tableName);
  bytesAddStr(&lookupKey, "HashTable");
  mtx_lock(sqlDatabase->tableDescriptions->lock);
  HashTable *tableDescription
    = (HashTable*) htGetValue(sqlDatabase->tableDescriptions, lookupKey);
  if (tableDescription == NULL) {
    sqlBuildTableDescriptions(sqlDatabase, dbName, tableName);
    tableDescription
      = (HashTable*) htGetValue(sqlDatabase->tableDescriptions, lookupKey);
  }
  mtx_unlock(sqlDatabase->tableDescriptions->lock);
  lookupKey = bytesDestroy(lookupKey);
  
  type = (TypeDescriptor*) htGetValue(tableDescription, fieldName);
  
  printLog(TRACE,
    "EXIT sqlGetFieldTypeByName(sqlDatabase=%p, dbName=%s, tableName=%s, "
    "fieldName=%s) = {%s}\n", sqlDatabase, strOrNull(dbName),
    strOrNull(tableName), strOrNull(fieldName),
    (type != NULL) ? type->name : "NULL");
  return type;
}

/// @fn TypeDescriptor* sqlGetFieldTypeByIndex(void *db, const char *dbName, const char *tableName, u64 fieldIndex)
///
/// @brief Get the type of a field in a table.
///
/// @param db A pointer to a SqlDatabase to query, cast to a void*.
/// @param dbName The name of the database in the system to query.
/// @param tableName The name of the table the field is in.
/// @param fieldIndex The index of the field in the table.
///
/// @return Returns a pointer to the relevant TypeDescriptor on success, NULL
/// on failure.
TypeDescriptor* sqlGetFieldTypeByIndex(void *db,
  const char *dbName, const char *tableName, u64 fieldIndex
) {
  SqlDatabase *sqlDatabase = (SqlDatabase*) db;
  
  printLog(TRACE,
    "ENTER sqlGetFieldTypeByIndex(sqlDatabase=%p, dbName=%s, tableName=%s, "
    "fieldIndex=%llu)\n", sqlDatabase, strOrNull(dbName), strOrNull(tableName),
    llu(fieldIndex));
  
  // Get the field types.
  Bytes lookupKey = NULL;
  bytesAddStr(&lookupKey, dbName);
  bytesAddStr(&lookupKey, tableName);
  bytesAddStr(&lookupKey, "Vector");
  mtx_lock(sqlDatabase->tableDescriptions->lock);
  Vector *tableDescription
    = (Vector*) htGetValue(sqlDatabase->tableDescriptions, lookupKey);
  if (tableDescription == NULL) {
    sqlBuildTableDescriptions(sqlDatabase, dbName, tableName);
    tableDescription
      = (Vector*) htGetValue(sqlDatabase->tableDescriptions, lookupKey);
  }
  mtx_unlock(sqlDatabase->tableDescriptions->lock);
  lookupKey = bytesDestroy(lookupKey);
  
  // If tableDescription is still NULL, vectorGetValue will return NULL.
  TypeDescriptor *type
    = (TypeDescriptor*) vectorGetValue(tableDescription, fieldIndex);
  
  printLog(TRACE,
    "EXIT sqlGetFieldTypeByIndex(sqlDatabase=%p, dbName=%s, tableName=%s, "
    "fieldIndex=%llu) = {%s}\n", sqlDatabase, strOrNull(dbName),
    strOrNull(tableName), llu(fieldIndex),
    (type != NULL) ? type->name : "NULL");
  return type;
}

/// @fn bool sqlInvalidateTableDescription(void *db, const char *dbName, const char *tableName)
///
/// @brief Invalidate the cached table description for an individual table.
///
/// @param db A pointer to a SqlDatabase to query, cast to a void*.
/// @param dbName The name of the database in the system the table is in.
/// @param tableName The name of the table to clear the table description
///   cache of.
///
/// @return Returns true on success, false on failure.
bool sqlInvalidateTableDescription(void *db,
  const char *dbName, const char *tableName
) {
  printLog(TRACE,
    "ENTER sqlInvalidateTableDescription(db=%p, dbName=%s, tableName=%s)\n",
    db, dbName, tableName);
  
  SqlDatabase *sqlDatabase = (SqlDatabase*) db;
  Bytes lookupKey = NULL;
  
  mtx_lock(sqlDatabase->tableDescriptions->lock);
  
  // Clear the hash table.
  bytesAddStr(&lookupKey, dbName);
  bytesAddStr(&lookupKey, tableName);
  bytesAddStr(&lookupKey, "HashTable");
  htRemoveEntry(sqlDatabase->tableDescriptions, lookupKey);
  lookupKey = bytesDestroy(lookupKey);
  
  // Clear the vector.
  bytesAddStr(&lookupKey, dbName);
  bytesAddStr(&lookupKey, tableName);
  bytesAddStr(&lookupKey, "Vector");
  htRemoveEntry(sqlDatabase->tableDescriptions, lookupKey);
  lookupKey = bytesDestroy(lookupKey);
  
  mtx_unlock(sqlDatabase->tableDescriptions->lock);
  
  printLog(TRACE,
    "EXIT sqlInvalidateTableDescription(db=%p, dbName=%s, tableName=%s) "
    "= {true}\n", db, dbName, tableName);
  return true;
}

/// @fn i64 sqlGetNumRecords(void *db, const char *dbString, const char *tableName)
///
/// @brief Update the contents of a record in the database.
///
/// @details This function replaces an existing record in the database with
///   a new one specified by the extra parameters in this function.
///
/// @param db A pointer to the SqlDatabase object representing the database
///   system to query cast to a void*.
/// @param dbString The name of the database in which the table is.
/// @param tableName The name of the table to query.
///
/// @return The number of records in the table on success, -1 on failure.
i64 sqlGetNumRecords(void *db, const char *dbString, const char *tableName) {
  SqlDatabase *database = (SqlDatabase*) db;
  printLog(TRACE,
    "ENTER sqlGetNumRecords(database=%p, dbString=\"%s\", tableName=\"%s\")\n",
    database, dbString, tableName);
  
  Bytes query = NULL;
  bytesAddStr(&query, "select count(*) from ");
  bytesAddStr(&query, dbString);
  bytesAddStr(&query, dbInstance);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  bytesAddStr(&query, ";");
  
  printLog(DEBUG, "Sending query \"%s\".\n", str(query));
  DbResult *queryResult = database->bytesQuery(database->connection, query);
  query = bytesDestroy(query);
  i64 returnValue = 0;
  if ((queryResult != NULL) && (queryResult->numResults > 0)) {
    TypeDescriptor *type = queryResult->fieldTypes[0];
    void *value = dbGetResultByIndex(queryResult, 0, 0, type);
    if (type == typeI64) {
      // The expected case.
      returnValue = (i64) *((i64*) value);
    } else if (type == typeI32) {
      returnValue = (i64) *((i32*) value);
    } else if (type == typeI16) {
      returnValue = (i64) *((i16*) value);
    } else if (type == typeI8) {
      returnValue = (i64) *((i8*) value);
    } else {
      // We don't know what this is or how to parse it.  Error.
      returnValue = -1;
    }
  }
  queryResult = dbFreeResult(queryResult);
  
  printLog(TRACE,
    "EXIT sqlGetNumRecords(database=%p, dbString=\"%s\", tableName=\"%s\") "
    "= {%lld}\n", database, dbString, tableName, lld(returnValue));
  return returnValue;
}

/// @fn DbResult* sqlGetOrValuesDict(void *database, const char *dbString, const char *tableName, const char *select, const char *orderBy, Dictionary *args)
///
/// @brief Low-level method for retrieving values from a table in a database.
///
/// @details This function performs an "OR" on the key-value pairs in the
/// dictionary instead of an "AND" like the other functions do.
///
/// @param database A pointer to the SqlDatabase object representing the database
///   system to query cast to a void*.
/// @param dbString The name of the database to qurey.
/// @param tableName The name of the table to query.
/// @param select The name of the field to examine.
/// @param orderBy The field(s) to order by, if any.  This parameter may be
///   NULL.
/// @param args The key-value pairs to OR together in the query.
///
/// @return A DbResult with the results of the query.
DbResult* sqlGetOrValuesDict(void *database,
  const char *dbString, const char *tableName,
  const char *select, const char *orderBy, Dictionary *args
) {
  SqlDatabase *sqlDatabase = (SqlDatabase*) database;
  char *dbName = NULL;
  straddstr(&dbName, dbString);
  straddstr(&dbName, dbInstance);
  
  printLog(TRACE,
    "ENTER sqlGetOrValuesDict(sqlDatabase=%p, dbName=\"%s\", tableName=\"%s\", "
    "select=\"%s\", orderBy=\"%s\")\n",
    sqlDatabase, dbName, tableName, (orderBy != NULL) ? orderBy : "", select);
  
  Bytes query = NULL;
  
  bytesAddStr(&query, "select ");
  bytesAddStr(&query, select);
  bytesAddStr(&query, " from ");
  bytesAddStr(&query, dbName);
  bytesAddStr(&query, ".");
  bytesAddStr(&query, tableName);
  
  if ((args != NULL) && (args->head != NULL)) {
    int keyTypeIndex = getIndexFromTypeDescriptor(args->keyType);
    int typeStringIndex = getIndexFromTypeDescriptor(typeString);
    int typeBytesNoCopyIndex = getIndexFromTypeDescriptor(typeBytesNoCopy);
    if ((keyTypeIndex >= typeStringIndex)
      && (keyTypeIndex <= typeBytesNoCopyIndex)
    ) {
      int typeStringNoCopyIndex = getIndexFromTypeDescriptor(typeStringNoCopy);
      int typeBytesIndex = getIndexFromTypeDescriptor(typeBytes);
      Bytes escapedValue = NULL;
      bytesAddStr(&query, " where ");
      
      for (DictionaryEntry *node = args->head; node != NULL; node = node->next) {
        bytesAddStr(&query, (char*) node->key);
        bytesAddStr(&query, "=");
        
        int valueTypeIndex = getIndexFromTypeDescriptor(node->type);
        if ((valueTypeIndex >= typeStringIndex)
          && (valueTypeIndex <= typeStringNoCopyIndex)
        ) {
          escapedValue = sqlDatabase->makeStringLiteral((char*) node->value);
        } else if ((valueTypeIndex >= typeBytesIndex)
          && (valueTypeIndex <= typeBytesNoCopyIndex)
        ) {
          escapedValue = sqlDatabase->makeBytesLiteral((Bytes) node->value);
        } else {
          escapedValue = node->type->toBytes(node->value);
        }
        
        bytesAddBytes(&query, escapedValue);
        escapedValue = bytesDestroy(escapedValue);
        
        if (node->next != NULL) {
          bytesAddStr(&query, " or ");
        }
      }
    }
  }
  
  if (orderBy != NULL) {
    bytesAddStr(&query, " order by ");
    bytesAddStr(&query, orderBy);
  }
  bytesAddStr(&query, ";");
  
  printLog(DEBUG, "Running query \"%s\"\n", query);
  DbResult *returnValue
    = sqlDatabase->bytesQuery(sqlDatabase->connection, query);
  query = bytesDestroy(query);
  printLog(DEBUG, "Got %llu query results \n", llu(returnValue->numResults));
  
  if ((returnValue->successful == true) && (returnValue->numFields == 0)) {
    // This isn't a valid state.  We issued a select statement that was
    // successful but returned no fields.  That means the whole result is empty.
    // Fix this.
    returnValue
      = _sqlFixMissingFields(returnValue, sqlDatabase, dbString, tableName, select);
  }
  
  printLog(TRACE,
    "EXIT sqlGetOrValuesDict(dbName=\"%s\", tableName=\"%s\", select=\"%s\", "
    "orderBy=\"%s\") = {%llu results}\n",
    dbName, tableName, select, (orderBy != NULL) ? orderBy : "",
    llu(returnValue->numResults));
  dbName = stringDestroy(dbName);
  return returnValue;
}

